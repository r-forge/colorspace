---
title: Coloring in R's Blind Spot
author:
  # see ?rjournal_article for more information
  - name: Achim Zeileis
    affiliation: UniversitÃ¤t Innsbruck
    address:
    - Department of Statistics
    url: https://www.zeileis.org/
    orcid: 0000-0003-0918-3766
    email:  Achim.Zeileis@R-project.org
  - name: Paul Murrell
    affiliation: University of Auckland
    address:
    - Department of Statistics
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
    email:  paul@stat.auckland.ac.nz
abstract: >
  Starting from R 4.0.0 R has a new and much improved default palette.
  More than 100 well-established palettes provided in `palette.colors()` and `hcl.colors()`.
  Overview and guidance.  
  **Meta:**
  Abstract must not have more than 150 words.
  File name of tex and bib should be the same.
  Compile document with `rmarkdown::render("color.Rmd")`.
  More details at <https://journal.R-project.org/share/author-guide.pdf>.  
preamble: |
  \newcommand{\doi}[1]{\href{https://doi.org/#1}{\normalfont\texttt{doi:\discretionary{}{}{}{#1}}}}
bibliography: color.bib
output: rticles::rjournal_article
---

```{r preliminaries, include = FALSE}
library("colorspace")
```

# Introduction

Color can be a very effective way to distinguish between different groups
within a data visualization.  Color is a "preattentive" visual feature,
meaning that groups are identified rapidly and without conscious effort
[@Ware:2012]. For example, it is trivially easy to identify the 
two groups of points in the scatterplot in Figure \ref{fig:colorcatcont}.

Employing color to represent values on a continuous numeric scale will be
less successful [@Cleveland+McGill:1984], but color can
still be useful to convey additional variables when more effective
visual features, such as location, have already been used.  For example,
color might be used to fill in different regions on a map, as
demonstrated in the right hand plot of Figure \ref{fig:colorcatcont}.

```{r colorcat, echo=FALSE, fig.height=4, fig.width=6, fig.show = 'hide'}
library("ggplot2")
data("whiteside", package = "MASS")
ggplot(whiteside, aes(Temp, Gas, color = Insul)) +
    geom_point(size = 2) +
    scale_color_manual(name = "Insulation", values = palette.colors(palette = "R4")[c(2, 4)]) +
    ggtitle("Whiteside's data") + xlab("Outside temperature") + ylab("Gas consumption") +
    theme(legend.position = "none") +
    theme_minimal()
```

```{r colorcont, echo=FALSE, fig.height=4, fig.width=3, fig.show = 'hide'}
library("tmap")
data("nz", package = "spData")
myfun <- function(x) {
  y <- format(round(x), big.mark = ",")
  z <- grepl("0,000", y, fixed = TRUE) | grepl("5,000", y, fixed = TRUE)
  z[range(seq_along(x))] <- TRUE
  y[!z] <- ""
  return(y)
}
tm_shape(nz) +
  tm_polygons(col = "Median_income",
    palette = "Blues", style = "cont", breaks = seq(20, 35, by = 5/3) * 1000,
    title = "Median income",
    legend.format = list(fun = myfun)) +
  tm_layout(frame = FALSE)
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.6\textwidth]{color_files/figure-latex/colorcat-1} 
\hfill
\includegraphics[width=0.28\textwidth]{color_files/figure-latex/colorcont-1}
\caption{Typical usage of color for coding qualitative/categorical (left) and quantiative/continuous (right) information.
Left: Scatter plot of weekly gas consumption by outside temperature before and after installing a house insulation.
Right: Choropleth map of median income in the 16 regions of New Zealand in 2018.
}\label{fig:colorcatcont}
\end{figure}


R provides several ways to specify colors:  by name (e.g., `"red"`);
by hexadecimal RGB code (e.g., `"#FF0000"`); or by integer (e.g., `2`).
When we specify an integer, that provides an index into a 
default set of colors;  the color `2`
means the second color in the default set of colors.

However, a more important task than specifying one particular color
is the task of specifying a set of colors to use in combination
with each other.
For example, in the left panel of Figure \ref{fig:colorcatcont}, we need two colors
that are very easily perceived as different from each other. 
In the right panel of Figure \ref{fig:colorcatcont}, we require a set of colors
that appear to change monotonically, e.g., from darker to lighter.

We call this the problem of selecting a good \emph{palette} of colors.
What we need to generate is a vector of R colors, e.g.,
`c("red", "blue")`, `c("#FF0000", "#0000FF")`, or `c(2, 4)`.

# A brief history of R palettes

Early versions of R provided very few functions for choosing colors from readily available palettes. And the palettes
that were provided were standard when they were implemented, but have meanwhile
been widely recognized as being rather poor.  

```{r echo=FALSE}
library("grid")
library("colorspace")
cellSize <- unit(4, "mm")
ncol <- 10
ns <- 3
gap <- unit(1, "lines")
border <- unit(0, "mm")
bgcol <- "grey80"
bgfill <- "white"
paletteGrid <- function(cols, qual=FALSE) {
    n <- length(cols)
    nrow <- ceiling(n / ncol)
    pushViewport(viewport(width=ncol*cellSize, height=nrow*cellSize,
                          x=0, y=1,
                          just=c("left", "top")))
    x <- rep((1:ncol - 1)/ncol, nrow)[1:n] + .5/ncol
    y <- rep(1 - (1:nrow - 1)/nrow, each=ncol)[1:n] - .5/nrow
    if (qual) {
        grid.circle(x, y, r=.4/nrow,
                    gp=gpar(col=darken(cols, .5), fill=cols, lwd=2))
    } else {    
        grid.rect(x, y, 
                  width=unit(1/ncol, "npc"),
                  height=unit(1/nrow, "npc"),
                  gp=gpar(col=darken(cols, .5), fill=cols, lwd=1,
                          linejoin="mitre"))
    }
    upViewport()
}
paletteGrids <- function(colList, nswatch=ns, qual=FALSE) {
    n <- length(colList)
    qual <- rep(qual, length.out=n)
    nrow <- ceiling(n / nswatch)
    layout <- grid.layout(nrow, nswatch,
                          heights=cellSize + gap,
                          widths=ncol*cellSize + gap,
                          just=c("left", "top"))
    pushViewport(viewport(width=unit(1, "npc") - 2*border,
                          height=unit(1, "npc") - 2*border,
                          layout=layout, name="top"))
    for (i in 1:n) {
        row <- (i-1) %/% nswatch + 1
        col <- (i-1) %% nswatch + 1
        if (!is.null(colList[[i]])) {
            pushViewport(viewport(layout.pos.row=row, layout.pos.col=col))
            grid.text(names(colList)[i], 0, unit(1, "npc") - .5*gap, 
                      just=c("left", "top"),
                      gp=gpar(cex=.7, fontfamily="mono"))
            pushViewport(viewport(y=unit(1, "npc") - gap, just="top"))
            paletteGrid(colList[[i]], qual=qual[i])
            upViewport(2)
        }
    }
    upViewport()
}
drawBorder <- function(row, y=.5, just="centre",
                       height=unit(1, "npc") + 2*border) {
  pushViewport(viewport(layout.pos.row=row, layout.pos.col=1:3))
  grid.rect(width=unit(1, "npc") + 2*border,
            height=height,
            y=y, just=just,
            gp=gpar(col=bgcol, fill=bgfill),
            name="bg1")
  upViewport()
}
drawBorder <- function(row, 
                       y1=unit(1, "npc") - unit(1, "mm"),
                       y2=unit(0, "npc"),
                       name=NULL) {
  pushViewport(viewport(layout.pos.row=row, layout.pos.col=1:3))
  grid.segments(unit(0, "npc") - border, y1,
                unit(0, "npc") - border, y2,
                gp=gpar(col=bgcol, lwd=7, lineend="butt"),
                name=name)
  upViewport()
}
drawBorder <- function(..., name=NULL) {
  grid.null(name=name)
}
```

```{r oldPalettes, echo=FALSE, fig.width=6, fig.height=3, fig.keep="last", out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='Old base R palettes.'}
paletteGrids(list("palette()"=palette.colors(palette="R3"),
                  "rainbow(8)"=rainbow(8),
                  "cm.colors(8)"=cm.colors(8),
                  "heat.colors(8)"=heat.colors(8), 
                  "topo.colors(8)"=topo.colors(8),
                  "terrain.colors(8)"=terrain.colors(8), 
                  "gray.colors(8)"=gray.colors(8)),
             qual=c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE))
downViewport("top")
drawBorder(1, name="bg1")
drawBorder(3:4, name="bg2")
drawBorder(6, name="bg3")
scene <- grid.grab()
scene <- reorderGrob(scene, c("bg1", "bg2", "bg3"))
grid.newpage()
grid.draw(scene)
```

The `palette()` function generated a vector of eight colors.
These provided the default set of colors that an integer color specification selects from
and could be used for coding _categorical_ information.

```{r echo=2}
palette("R3")
palette()
palette("R4")
```

See also Figure \ref{fig:oldPalettes} that depicts `palette()` along
with other old base R palettes using "swatches" of rectangles filled with the
corresponding colors. The other palette functions  all take an argument `n` to generate
that number of colors (possibly along with further arguments that allow for
certain customizations):

* `heat.colors()`, `terrain.colors()`, `topo.colors()`, and `gray.colors()`
  could be used as _sequential_ palettes for ordered or numeric information.
* `cm.colors()` could be used as a _diverging_ palette for values that are
  distributed around a "neutral" value, such as zero.
* `rainbow()` implements the infamous rainbow (or "jet") color palette 
  that was very widely used for all types (possibly after restricting 
  the hue range): _categorical_, _sequential_, and _diverging_.

All of these palettes -- except `gray.colors()` -- have poor perceptual properties.
The colors are highly saturated, which can be distracting and overly 
stimulating, and the colors are unbalanced with respect to chroma and luminance,
which means that they have unequal visual impact
[@Lonsdale+Lonsdale:2019; @Bartram+Patra+Stone:2017; @Etchebehere+Fedorovskaya:2017]. 
In addition, the palettes do not perform well for viewers with some form
of colorblindness (nearly 10% of the population).
Most of the palettes also use sequences
of hues obtained in the RGB (red-green-blue) space or simple derivations thereof like HSV (hue-saturation-value) or HLS (hue-lightness-saturation),
which leads to clustering of colors at the red, green, and blue primaries.

Although these limitations have been well known for some time, no changes
were made to these palettes provided by the core R graphics system for
a number of years. The were various reasons for this including the following:

In R version 2.1.0, Thomas Lumley added the `colorRampPalette()` function.
This makes it easier to generate a palette, though the user is still required
to select, for example, start and end colors from which
a palette of colors can then be interpolated.

Over time, 
better palettes became available via packages on CRAN (Comprehensive R Archive Network)
  starting with \CRANpkg{RColorBrewer} [@RColorBrewer], later
  \CRANpkg{colorspace} [@Ihaka:2003; @Zeileis+Hornik+Murrell:2009], and somewhat more recently
  \CRANpkg{viridis} [@viridis], \CRANpkg{rcartocolor} [@rcartocolor], or \CRANpkg{scico} [@scico],
  among many others.

In addition, higher-level graphics systems
 like \CRANpkg{ggplot2} [@ggplot2] and \CRANpkg{lattice} [@lattice]
developed their own color themes.

```{r oldbase, eval=FALSE, echo=FALSE, fig.height=1.75, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='Old R palette functions.  The label above each swatch shows the function call that produces that set of colors.'}
oldbase.pals <- function() {
  c("default (R3)", "rainbow", paste0(c("heat", "terrain", "topo", "cm", "gray"), ".colors"))
}

oldbase.colors <- function(n, palette = "default", ...) {
  palette <- match.arg(palette, oldbase.pals())
  if(palette == oldbase.pals()[1]) {
    palette.colors(n, palette = "R3", ...)
  } else {
    do.call(palette, list(n = n, ...))
  }
}

oldbase.swatch <- function(palette = oldbase.pals(), n = 8, nrow = 2,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, oldbase.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}

oldbase.swatch()
```

# A new set of R palettes

On the road to R version 4.0.0 an attempt was made to
address the limited and deficient set of palettes that are available 
within the core R graphics sytem and to add a range of modern color palettes.
In particular, `palette()` has a new improved default color palette,
`palette.colors()` provides further well-established qualitative palettes [@grDevices2], and
`hcl.colors()` provides a wide range of qualitative, sequential, and diverging palettes obtained by a standardized approach in
the so-called HCL (hue-chroma-luminance) space [@Wiki+HCL], see @grDevices and @Zeileis+Fisher+Hornik:2020.


## A new default color palette

The default color palette in R -- the default set of colors that can
be specified by integer index -- has been replaced.  The new palette
follows the same basic hues as the old default palette, but
the palette is less saturated overall and
reduces the size of changes in chroma and luminance across the palette.
This produces a calmer and less distracting palette with a more
even visual impact.
An attempt has also been made to improve the discriminability
of the colors in the default palette for colorblind viewers.
The new, "R4", default palette is shown at top-left of Figure 
\ref{fig:newPalettes}.
More information about the construction of the new default palette
is given in [@grDevices2].

```{r newPalettes, echo=FALSE, fig.width=6, fig.height=4, fig.keep="last", out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='New base R palettes available from the \\code{palette.colors()} function.  The label above each swatch shows the argument to provide to \\code{palette.colors()} to produce the set of colors.  The palette at top-left is the new default that is also produced by \\code{palette()}.  The "Okabe-Ito" palette is the default that is produced by \\code{palette.colors()} (with no arguments).'}
paletteGrids(list('palette="R4"'=palette.colors(palette="R4"),
                  'palette="Okabe-Ito"'=palette.colors(palette="Okabe-Ito"),
                  blank=NULL,
                  blank=NULL,
                  blank=NULL,
                  blank=NULL,
                  'palette="ggplot2"'=palette.colors(palette="ggplot2"),
                  'palette="Tableau 10"'=palette.colors(palette="Tableau 10"),
                  'palette="Classic Tableau"'=palette.colors(palette="Classic Tableau"),
                  blank=NULL,
                  blank=NULL,
                  blank=NULL,
                  'palette="Accent"'=palette.colors(palette="Accent"),
                  'palette="Paired"'=palette.colors(palette="Paired"),
                  'palette="Pastel 1"'=palette.colors(palette="Pastel 1"),
                  'palette="Pastel 2"'=palette.colors(palette="Pastel 2"),
                  'palette="Set 1"'=palette.colors(palette="Set 1"),
                  'palette="Set 2"'=palette.colors(palette="Set 2"),
                  'palette="Set 3"'=palette.colors(palette="Set 3"),
                  'palette="Dark 2"'=palette.colors(palette="Dark 2"),
                  blank=NULL,
                  blank=NULL,
                  blank=NULL,
                  blank=NULL,
                  'palette="Alphabet"'=palette.colors(palette="Alphabet"),
                  'palette="Polychrome 36"'=palette.colors(palette="Polychrome 36")),
              qual=TRUE)
downViewport("top")
drawBorder(1, name="bg1")
drawBorder(3, name="bg2")
drawBorder(5:7, name="bg3")
drawBorder(9, name="bg4",
           y2=unit(1, "npc") - 4*cellSize - gap)
scene <- grid.grab()
scene <- reorderGrob(scene, c("bg1", "bg2", "bg3", "bg4"))
grid.newpage()
grid.draw(scene)
```

```{r swatch, echo=FALSE}
palette.swatch <- function(palette = palette.pals(), n = 8, nrow = 4,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, palette.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}
```
```{r oldvsnew, echo=FALSE, eval=FALSE, fig.width=6, fig.height=1}
paletteGrids(list('"R3"'=palette.colors(palette="R3"), 
                  '"R4"'=palette.colors(palette="R4")),
             nswatch=1)
```

## The `palette.colors()` function

The `palette.colors()` function, new in R 4.0.0, provides a way to
access several other predefined palettes (see Figure \ref{fig:newPalettes}).
All of these are *qualitative palettes* because they are appropriate for 
encoding qualitative (categorical) variables.  In other words,
these palettes are appropriate for differentiating between groups.

By default `palette.colors()` returns the 
`Okabe-Ito` [@Okabe+Ito:2008] palette.  This palette
 was designed to be very robust under color vision deficiencies, so
the different colors in this palette should be distinguishable
for all viewers. 

```{r okabeito, echo=FALSE, eval=FALSE, fig.width=2, fig.height=.5}
paletteGrids(list("palette.colors()"=palette.colors()))
```

The `palette` argument allows us to select a different palette.
For example, the old R default palette is available via the name `"R3"`.
This palette is really only useful to reproduce old behaviour
and remind us how bad things used to be.

```{r r3, echo=FALSE, eval=FALSE, fig.width=2, fig.height=.5}
paletteGrids(list('palette="R3"'=palette.colors(palette="R3")))
```

There are several palettes that have been taken from the color schemes of
the \pkg{ggplot2} package and Tableau [@Tableau], both 
well-established graphics systems.  The `"Tableau 10"` palette
represents the redesign of the default palette in Tableau [@Stone:2016].
These palettes may be useful
to emulate the look and feel of plots from those other systems.

```{r otherssystems, echo=FALSE, eval=FALSE, fig.width=6, fig.height=.5}
paletteGrids(list('palette="ggplot2"'=palette.colors(palette="ggplot2"),
                  'palette="Tableau 10"'=palette.colors(palette="Tableau 10"),
                  'palette="Classic Tableau"'=palette.colors(palette="Classic Tableau")))
```

Several palettes come from ColorBrewer.org [@Harrower+Brewer:2003] and
were originally designed for filling regions on maps. However, they
are also useful for filling regions within data visualizations like bar plots, 
density plots, and heatmaps, among others.
Two of these palettes are a bit different because 
they deliberately contain darker and lighter colors:
the `"Accent"` palette may be useful to emphasise one or more categories
over the others;
the `"Paired"` palette may be useful to represent more than one
categorical variable via color, e.g., high vs. low versions of 
            

```{r colorbrewer, echo=FALSE, eval=FALSE, fig.width=6, fig.height=2}
paletteGrids(list('palette="Accent"'=palette.colors(palette="Accent"),
                  'palette="Paired"'=palette.colors(palette="Paired"),
                  'palette="Pastel 1"'=palette.colors(palette="Pastel 1"),
                  'palette="Pastel 2"'=palette.colors(palette="Pastel 2"),
                  'palette="Set 1"'=palette.colors(palette="Set 1"),
                  'palette="Set 2"'=palette.colors(palette="Set 2"),
                  'palette="Set 3"'=palette.colors(palette="Set 3"),
                  'palette="Dark 2"'=palette.colors(palette="Dark 2")))
```

Finally, there are two palettes from the 
\CRANpkg{Polychrome} package [@Polychrome].
These are much larger palettes, with colors chosen to be evenly
spread throughout HCL colorspace.  The `"Polychrome 36"` palette
represents the largest set of colors that could be generated
while still being visually distinguishable.  The `"Alphabet"`
palette is just a smaller, but still large, set (one for each letter
of the alphabet).  These palettes
may be useful if you are attempting to represent a very large
number of categories at once.  The result is unlikely to be
easy to interpret, but these palettes will be your best chance.

```{r polychrome, echo=FALSE, eval=FALSE, fig.width=6, fig.height=3}
paletteGrids(list('palette="Alphabet"'=palette.colors(palette="Alphabet"),
                  'palette="Polychrome 36"'=palette.colors(palette="Polychrome 36")))
```

The `palette.pals()` function returns a character vector of 
the available palette names.

```{r}
palette.pals()
```

The first argument to `palette.colors()` is a number of colors.
Each palette has a fixed number of colors, but we can ask for fewer or,
with `recycle = TRUE`, we can get more colors by recycling.

  ```{r recycle, echo=FALSE, fig.width=6, fig.height=3}
  paletteGrids(list('palette.colors(4)'=palette.colors(4),
                    'palette.colors(10, recycle=TRUE)'=palette.colors(10, recycle=TRUE)), qual=TRUE)
  ```

Each of these palettes can be set as the default palette by passing
the palette name to the `palette()` function.  For example,
the following code sets the Okabe-Ito palette as the default palette.

```{r}
palette("Okabe-Ito")
```

## The `hcl.colors()` function

The `hcl.colors()` function was also added in R 4.0.0.
This function provides access to another range of palettes, this time
including sequential and diverging palettes as well as qualitative 
palettes.  As with the `palette.colors()` function, the first
argument is a number of colors to generate and the second argument
specifies a palette to generate colours from.

```{r}
hcl.colors(5, palette="viridis")
```

One difference with `hcl.colors()` is that the palette we are
 selecting colors from is \emph{not}
a fixed set of colours.
Instead, the palettes in `hcl.colors()` are a path within
HCL space.

```{r echo=FALSE}
library(colorspace)
cols <- hcl.colors(5000, "viridis")
rgb <- col2rgb(cols)
 lch <- as(RGB(t(rgb)), "polarLUV")
pairs(coords(lch), col=cols,
      panel=function(x, y, col, ...) {
          n <- length(x)
          segments(x[-n], y[-n], x[-1], y[-1], col=cols[-n], lwd=2)
      })
```

This means that we can select as many colors as we like from these
palettes.
The `hcl.pals()` function provides a full list of the
available palette names that we can choose from.

Most of these palettes have one or more desirable perceptual properties:

* **perceptual uniformity**. This means that if we take a step along
  the path of the palette in HCL space, the perceived difference
  between the two colors will be the same anywhere along the path.
* **perceptual order**.  This means that there is a perceived ordering
  of the colors, typically arising from a monotonic change from
  light to dark or vice versa.
* **colorblind-safe**.  This means that the palette retains
  its perceptual properties for colorblind users.
* **perceptual balance**.  This means that, for example,
  while there are changes in hue, chroma and luminance remain 
  pretty much the same.  
  

```{r echo=FALSE}
source("classification.R")
pals$name <- tolower(substring(rownames(pals), 3))
hclpals <- merge(data.frame(name=tolower(hcl.pals())), pals)
plotSource <- function(p, start=0) {
    typepals <- split(p, p$type, drop=TRUE)
    names(typepals) <- NULL
    rotate <- function(x, start=0) {
        low <- x < start
        if (any(low))
            x[low] <- x[low] + 360
        x
    }   
    reorder <- function(n) {
        m1 <- matrix(1:n, ncol=3, byrow=TRUE)
        m2 <- matrix(1:length(m1), ncol=3, byrow=TRUE)
        m1[m2 > n] <- NA
        m1[!is.na(m1)] <- 1:n
        index <- as.numeric(t(m1))
        index[!is.na(index)]
    }
    palBlock <- function(pals) {
        cols <- lapply(pals$name, 
                       function(x) hcl.colors(7, palette=x))
        names(cols) <- pals$name
        n <- length(cols)
        c1 <- sapply(cols, "[", 1)
        h1 <- colorspace::coords(as(colorspace::hex2RGB(c1), "polarLUV"))[, "H"]
        index <- suppressWarnings(reorder(n))
        o <- order(rotate(h1, start))[index]
        nrow <- ceiling(n/3)
        if (3*nrow != n) cols <- c(cols[o], 
                                   vector("list", 
                                          3*nrow - n))
        c(cols, vector("list", 3))
    }
    palLists <- lapply(typepals, palBlock)
    qualBlock <- function(pals) {
        qual <- pals$type == "qualitative"
        n <- length(qual)
        cols <- lapply(pals$name, 
                       function(x) hcl.colors(7, palette=x))
        c1 <- sapply(cols, "[", 1)
        h1 <- colorspace::coords(as(colorspace::hex2RGB(c1), "polarLUV"))[, "H"]
        index <- suppressWarnings(reorder(n))
        o <- order(rotate(h1, start))[index]
        nrow <- ceiling(n/3)
        if (3*nrow != n) qual <- c(qual[o], 
                                   rep(FALSE, 
                                       3*nrow - n))
        c(qual, rep(FALSE, 3))
    }
    palQuals <- lapply(typepals, qualBlock)
    palArg <- unlist(palLists, recursive=FALSE, use.names=TRUE)
    names(palArg) <- paste0('palette="', names(palArg), '"')
    do.call(paletteGrids, list(palArg, qual=unlist(palQuals)))
    invisible()
}          
pkgpals <- split(hclpals, hclpals$source)
```

Many of the palettes provided by `hcl.colors()` are close approximations
to well-known palettes from other sources.  For example,
the palettes shown in Figure \ref{fig:viridisPalettes} are 
from the \pkg{viridis} package.  These are all sequential palettes,
but with a large change in hue as well, which makes them quite colorful
and eye-catching.

The `"viridis"`, `"plasma"`,
and `"inferno"` palettes come from the matplotlib Python library
and work well for identifying features of interest in false-color images.
This means that they should also work well for heatmaps.  
The large range of hues means that these palettes can also serve
as qualitative palettes, which makes them robust default palettes.
However, this versatility means that 
a palette that is purely sequential or purely qualitative may serve better 
for specific purposes.

The `"cividis"` palette is a version of `"viridis"` that is optimized
for colorblind viewers.  This is necessarily less colorful because of
the reduced range of hues available.
The `"mako"` and `"rocket"` palettes are from the Seaborn Python
library with an emphasis on high chroma and a wide range of luminance.
This makes these palettes a good choice for heatmaps.

```{r viridisPalettes, echo=FALSE, fig.width=6, fig.height=7, out.width='\\textwidth', fig.align='center', fig.pos='ht!', fig.cap='viridis palettes.'}
grid.newpage()
plotSource(pkgpals[[4]])
```

Figure \ref{fig:colorBrewerPalettes} shows a range of 
sequential and diverging palettes from ColorBrewer.org
(`palette.colors()` only provides qualitative palettes).
These palettes have also been selected to be colourful.

These palettes are designed for filling regions within maps,
so they should work well for filling regions (barplots,
heatmaps, and of course maps).

Several of the sequential palettes vary only from dark to light, with
a selection of underlying hues.  Certain hues will be more 
appropriate for representing data on specific concepts, such
as green for "nature" and red for "temperature".  Other
sequential palettes also vary hue;  this may be appropriate 
for drawing attention to very high or very low values.

The diverging palettes again offer a range of underlying hues
for either extreme, with either white or yellow as the central "neutral"
value.  The palettes with yellow at the centre provide less of a
change in colourfulness, so the "neutral" value is more of 
a turning point rather than a local minimum.  This is particularly
true of the `"spectral"` palette which is almost a qualitative
palette rather than a diverging palette.

The ColorBrewer.org palettes were designed with good perceptual properties
in mind, but also relied on expert opinion and trial and error.
This means that a little more care should be taken when selecting one
of these palettes because, for example, they are not all colorblind-safe.

```{r colorBrewerPalettes, echo=FALSE, fig.width=6, fig.height=7, out.width='\\textwidth', fig.align='center', fig.pos='ht!', fig.cap='RColorBrewer palettes.'}
grid.newpage()
plotSource(pkgpals[[2]], start=100)
```

\newpage

Definitely designed with perception principles in mind and
with colorblind viewers in mind.
One point of difference is that there are diverging palettes 
that go light-dark-light instead of dark-light-dark.
The palettes seem relatively dark overall.

```{r echo=FALSE, fig.width=6, fig.height=7, out.width='\\textwidth', fig.align='center', fig.pos='ht!', fig.cap='scico palettes.'}
grid.newpage()
plotSource(pkgpals[[3]])
```

\newpage

I could find no background material on the \pkg{rcartocolor} palettes
(only got as far as the CARTO marketing material).  No good evidence
that these have been constructed with perceptual properties in mind.

Like the ColorBrewer.org palettes, there are both single-hue sequential
palettes and multi-hue sequential palettes.
These palettes tend to span a narrower range of lightness
compared to the ColorBrewer.org palettes;  the darkest color is less
dark and the lightest color is less light.  This means that
these palettes should only be used to select a small number of colors;
fewer distinct colors can be selected from these palettes.

```{r echo=FALSE, fig.width=6, fig.height=7, out.width='\\textwidth', fig.align='center', fig.pos='ht!', fig.cap='rcartocolor palettes.'}
grid.newpage()
plotSource(pkgpals[[1]], start=100)
```

\newpage


 base R was finally overcome by introducing two new palette functions:

- `palette.colors()` provides a new improved default color palette as well as a few other well-established qualitative palettes [@grDevices2]
- `hcl.colors()` provides a wide range of qualitative, sequential, and diverging palettes obtained by a standardized approach in
  the so-called HCL (hue-chroma-luminance) space [@Wiki+HCL], see @grDevices and @Zeileis+Fisher+Hornik:2020.
  Most of these HCL palettes approximate very closely well-established palettes from \pkg{RColorBrewer}, \pkg{viridis}, \pkg{rcartocolor},
  \pkg{scico}, and others.

Both are accompanied by functions to query the available palette names (`palette.pals()` and `hcl.pals()`, respectively).
The color swatches shown in Figures \ref{fig:palette}, \ref{fig:hcls}, and \ref{fig:hcld} which are also shown by running
the `example()` of the two functions which make basic `palette.swatch()` and `hcl.swatch()` functions available.
Here, focus on `palette.colors()`, more details on `hcl.colors()` later.

```{r palette, echo=FALSE, fig.height=3.5, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{palette.colors()}.'}
## height=5, width=12
palette.swatch()
```

Briefly explain principles for selection of `R4` (similar hues, limited differences in chroma/luminance, dark/colorful, work ok for colorblind viewers).
`Okabe-Ito` [@Okabe+Ito:2008] was designed to be very robust under color vision deficiencies. As it uses somewhat different hues than the old `R4` palette
and was hence not used as the new default palette in R but it is the default in `palette.colors()`.
The robustness of both palettes is illustrated in Figure \ref{fig:cvd}.

```{r cvd, echo=FALSE, fig.height=3.5, fig.width=12, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Color vision deficiency emulation for \\code{R4} (left) and \\code{Okabe-Ito} (right) palettes.'}
layout(rbind(1:2), widths = c(0.46, 0.54))
swatchplot(palette.colors(palette = "R4"), cvd = TRUE)
swatchplot(palette.colors(palette = "Okabe-Ito"), cvd = TRUE)
```

The other palettes are from well-established software packages like \pkg{ggplot2} [@ggplot2], ColorBrewer.org [@Harrower+Brewer:2003],
or Tableau [@Tableau]. Moreover, two palettes with many colors (36 and 26, respectively) are used from the
\CRANpkg{Polychrome} package [@Polychrome].

## Illustration

Show usage of new qualitative palettes in practice. Consider:
Power of color often overestimated.
Color vision deficiencies ($\sim 8$% of male and $\sim 0.5$% of female viewers).
Other physical or technical limitations.

Starting point: Time series line plot using base graphics, see Figure \ref{fig:tsplot} (top left), essentially:

```{r tsplot-pseudocode, eval=FALSE}
p <- c(1:3, 5)
plot(EuStockMarkets, log = "y", plot.type = "single", col = p, ...)
legend("topleft", colnames(EuStockMarkets), col = p, ...)
```

The first two rows show the old default colors from R 3.x.y and the new default colors startin from R 4.0.0.
Additionally, the figure uses @Okabe+Ito:2008 palette and it switches from a color legend to direct labeling.

In the right column: Emulation of a kind of red-green
color blindness known as protanopia using the \pkg{colorspace} package based on
the algorithms of @Machado+Oliveira+Fernandes:2009.

```{r tsplot, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Time series line plot of \\code{EuStockMarkets}. Rows: Old \\code{"R3"} default palette (top), new \\code{"R4"} default palette (middle), \\code{"OkabeIto"} palette (bottom), designed to be robust under color vision deficiencies. Columns: Normal vision (left) and emulated protanope vision (right). A color legend is used in the first row and direct labels in the other rows.'}
tsplot <- function(palette = "R3", protan = FALSE, legend = TRUE, ...) {
  ## color palette
  palette <- match.arg(palette, c("R3", "R4", "Okabe-Ito"))
  p <- switch(palette,
    "R3" = palette.colors(8, "R3")[c(1:3, 5)],
    "R4" = palette.colors(8, "R4")[c(1:3, 5)],
    "Okabe-Ito" = palette.colors(4, "Okabe-Ito")[c(1, 4, 2, 3)]
  )
  
  ## emulate protanope vision?
  if(protan) p <- colorspace::protan(p) 
  
  ## time series plot
  eu <- window(EuStockMarkets, end = 1998)
  plot(eu, log = "y", ylab = "EU Stock Prices", plot.type = "single", col = p, xlim = c(1991.6, 1998.4), lwd = 1.5, ...)
  text(1991.3, 6000, palette, pos = 4, cex = 1.5)

  ## legend or direct labeling
  if(legend) {
    legend(1991.3, 6000, colnames(eu), col = p, lty = 1, lwd = 3, bty = "n")
  } else {
    text(1998, tail(eu, 1), colnames(eu), pos = 4, col = p, xpd = TRUE)
  }
  
  invisible(p)
}

par(mfrow = c(3, 2), mar = c(5, 4, 2, 1))
tsplot(palette = "R3", protan = FALSE, legend = TRUE, main = "Normal")
tsplot(palette = "R3", protan = TRUE, legend = TRUE, main = "Protanope")
par(mar = c(5, 4, 1, 1))
tsplot(palette = "R4", protan = FALSE, legend = FALSE)
tsplot(palette = "R4", protan = TRUE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = FALSE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = TRUE, legend = FALSE)
```

Old `R3` default palette: Too flashy, cyan too light, hard to distinguish for protanope viewers.
The colors for the German stock index DAX and the Swiss stock index SMI look almost identical to protanope viewers.

New `R4` default palette: Similar hues, more balanced brightness, avoid garish colors, distinguishable for viewers with color vision deficiencies. Cyan much better.

`Okabe-Ito`: Even easier to distinguish.


# HCL-based color palettes

## Construction principles

HCL makes it easy to describe colors for humans, using the three basic properties hue, chroma, and luminance (see Figure \ref{fig:hcl}).

```{r hcl, echo=FALSE, fig.height=2.4, fig.width=5, out.width='0.4\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Varying hue, chroma, and luminance separately, keeping the other two properties fixed.'}
swatchplot(
  "Hue\n(Type of color)"    = sequential_hcl(5, h = c(0, 300), c = c(60, 60), l = 65),
  "Chroma\n(Colorfulness)"  = sequential_hcl(5, h = 0, c = c(100, 0), l = 65, rev = TRUE, power = 1),
  "Luminance\n(Brightness)" = sequential_hcl(5, h = 260, c = c(25, 25), l = c(25, 90), rev = TRUE, power = 1),
  nrow = 3, line = 8, off = 0
)
```

For qualitative palettes mainly vary hue. Completely balanced if chroma and luminance kept fixed which
was suggested by @Ihaka:2003 and is implemented in `hcl.colors()`. See left panel of Figure \ref{fig:hclpal}
and Figure \ref{fig:hclq}.
Two drawbacks: Relatively few colors that can be clearly distinguished (about six), even fewer under
color vision deficiencies (about three). Hence in most situations better allow limited variations in chroma and luminance
as in `palette.colors()`. No general HCL-based strategy for such palettes.

```{r hclpal, echo=FALSE, fig.height=2.4, fig.width=15, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Basic idea for HCL palettes.'}
swatchplot(
  "Qualitative (Set 2)"     = rbind("Color" = hcl.colors(5, "Set 2"),     "Desaturated" = desaturate(hcl.colors(5, "Set 2"))),
  "Sequential (Blues)"    = rbind("Color" = hcl.colors(7, "Blues"),    "Desaturated" = desaturate(hcl.colors(7, "Blues"))),
  "Diverging (Green-Brown)" = rbind("Color" = hcl.colors(7, "Green-Brown"), "Desaturated" = desaturate(hcl.colors(7, "Green-Brown"))),
  nrow = 3, off = 0, line = 7
)
```
For sequential and diverging palettes monotonic changes in luminance are most important (see middle and right panel
in Figure \ref{fig:hclpal}). Add changes in chroma and possibly also hue (see Figure \ref{fig:specplot}).
`Blues 2` uses a constant hue and monotonic changes in chroma and luminance going from dark and colorful blue to
light gray. `Blues` uses similar luminance trajectory, slightly varies hue, and has triangular chroma curve (rather
than monotonic). `Blues 2` mostly emphasizes the dark and colorful blue while `Blues` makes the colors more easily
distinguishable in the middle.

Diverging combines two sequential, making both arms as balanced as possible.


```{r specplot, echo=TRUE, fig.height=5, fig.width=5, fig.show='hide'}
specplot(hcl.colors(7, "Blues"), hcl.colors(7, "Blues 2"))
specplot(hcl.colors(7, "Green-Brown"))
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-1} 
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-2}
\caption{Spectrum of luminance (blue, left axis), chroma (green, left axis), and hue (red, right axis) trajectories.
Left: Sequential \code{Blues} (solid) and \code{Blues 2} (dashed) palettes.
Right: Diverging \code{Green-Brown} palette.}\label{fig:specplot}
\end{figure}


## Available palettes

Overview of qualitative (Figure \ref{fig:hclq}), sequential (Figure \ref{fig:hcls}), and diverging (Figure \ref{fig:hcld})
palettes based on HCL principles. Many closely approximate colors from ColorBrewer.org, CARTO Color, Viridis, and 
Crameri's scientific colors. See <http://colorspace.R-Forge.R-project.org/articles/approximations.html> for one-to-one
comparisons.

```{r hclq, echo=FALSE, fig.height=2, fig.width=8, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{hcl.colors()}.'}
hcl.swatch <- function(palette = NULL, type = NULL, n = 5, nrow = 11,
  border = if (n < 15) "black" else NA, ...) {
    if(is.null(palette)) palette <- hcl.pals(type)
    cols <- sapply(palette, hcl.colors, n = n)
    ncol <- ncol(cols)
    nswatch <- min(ncol, nrow)

    par(mar = rep(0.1, 4),
        mfrow = c(1, min(6, ceiling(ncol/nrow))),
        cex = 0.7, ...)

    while (length(palette)) {
        subset <- 1:min(nrow, ncol(cols))
        plot.new()
        plot.window(c(0, n), c(0, nrow + 1))
        text(0, rev(subset) + 0.1, palette[subset], adj = c(0, 0))
        y <- rep(subset, each = n)
        rect(rep(0:(n-1), n), rev(y), rep(1:n, n), rev(y) - 0.5,
             col = cols[, subset], border = border)
        palette <- palette[-subset]
        cols <- cols[, -subset, drop = FALSE]
    }

    par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), cex = 1)
}

hcl.swatch(type = "qualitative", nrow = 2)
```

```{r hcls, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Sequential palettes from \\code{hcl.colors()}.'}
hcl.swatch(type = "sequential", nrow = 12)
```

```{r hcld, echo=FALSE, fig.height=4.5, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Diverging palettes from \\code{hcl.colors()}.'}
hcl.swatch(c(hcl.pals("diverging"), hcl.pals("divergingx")), nrow = 6)
```

## Illustration

Risk maps: Communication to the public particularly important.

Example: Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04, during hurricane Dorian.

Source: National Oceanic and Atmospheric Administration.

Original: Works poorly because too much chroma everywhere and non-monotonic luminance (dark to light and back to dark).
Extremely hard to read for colorblind viewers (see Figure \ref{fig:dorian}).

Better HCL-based alternative: `OrRd` and also merging some probability intervals to make matching of intervals to colors easier, still clearly conveys overall shape.

Might have contributed to Trump's confusion in "Sharpiegate" incident. See @Zeileis+Stauffer:2019 for a more detailed discussion and other alternative color palettes.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig-deutan.png} 

\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd-deutan.png} 
\caption{Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04..}\label{fig:dorian}
\end{figure}




# New defaults in graphical functions

Many graphics functions have now slightly different default output, namely when they are using colors `2`, `3`, `4`, etc. but still red, green, blue.

Moreover, a couple of functions explicitly have new defauls, namely: `image()` and `filled.contour()`, now using sequential `YlOrRd` palette
(from ColorBrewer) which uses similar hues as the old `heat.colors()`. See Figure \ref{fig:graphics}.

Finally, it might be worth mentioning that `hist()` and `boxplot()` (and thus `plot(num ~ factor, ...)`) have a new default color:
light gray which makes it a bit easier to compare the shaded areas.

```{r graphics, echo=-1, fig.height=4, fig.width=14, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='New defaults in base graphics.'}
par(mfrow = c(1, 3))
image(volcano)
boxplot(weight ~ feed, data = chickwts)
hist(chickwts$weight)
```


