---
title: Coloring in R's Blind Spot
author:
  # see ?rjournal_article for more information
  - name: Achim Zeileis
    affiliation: UniversitÃ¤t Innsbruck
    address:
    - Department of Statistics
    url: https://www.zeileis.org/
    orcid: 0000-0003-0918-3766
    email:  Achim.Zeileis@R-project.org
  - name: Paul Murrell
    affiliation: University of Auckland
    address:
    - Department of Statistics
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
    email:  paul@stat.auckland.ac.nz
abstract: >
  Starting from R 4.0.0 R has a new and much improved default palette.
  More than 100 well-established palettes provided in `palette.colors()` and `hcl.colors()`.
  Overview and guidance.  
  **Meta:**
  Abstract must not have more than 150 words.
  File name of tex and bib should be the same.
  Compile document with `rmarkdown::render("color.Rmd")`.
  More details at <https://journal.R-project.org/share/author-guide.pdf>.  
preamble: |
  \newcommand{\doi}[1]{\href{https://doi.org/#1}{\normalfont\texttt{doi:\discretionary{}{}{}{#1}}}}
bibliography: color.bib
output: rticles::rjournal_article
---

```{r preliminaries, include = FALSE}
library("colorspace")
```

# Introduction

Color can be a very effective way to distinguish between different groups
within a data visualization.  Color is a "preattentive" visual feature,
meaning that groups are identified rapidly and without conscious effort
[@Ware:2012]. For example, it is trivially easy to identify the 
two groups of points in the scatterplot in Figure \ref{fig:colorcatcont}.

Employing color to represent values on a continuous numeric scale will be
less successful [@Cleveland+McGill:1984], but color can
still be useful to convey additional variables when more effective
visual features, such as location, have already been used.  For example,
color might be used to fill in different regions on a map, as
demonstrated in the right hand plot of Figure \ref{fig:colorcatcont}.

```{r colorcat, echo=FALSE, fig.height=4, fig.width=6, fig.show = 'hide'}
library("ggplot2")
data("whiteside", package = "MASS")
ggplot(whiteside, aes(Temp, Gas, color = Insul)) +
    geom_point(size = 2) +
    scale_color_manual(name = "Insulation", values = palette.colors(palette = "R4")[c(2, 4)]) +
    ggtitle("Whiteside's data") + xlab("Outside temperature") + ylab("Gas consumption") +
    theme(legend.position = "none") +
    theme_minimal()
```

```{r colorcont, echo=FALSE, fig.height=4, fig.width=3, fig.show = 'hide'}
library("tmap")
data("nz", package = "spData")
myfun <- function(x) {
  y <- format(round(x), big.mark = ",")
  z <- grepl("0,000", y, fixed = TRUE) | grepl("5,000", y, fixed = TRUE)
  z[range(seq_along(x))] <- TRUE
  y[!z] <- ""
  return(y)
}
tm_shape(nz) +
  tm_polygons(col = "Median_income",
    palette = "Blues", style = "cont", breaks = seq(20, 35, by = 5/3) * 1000,
    title = "Median income",
    legend.format = list(fun = myfun)) +
  tm_layout(frame = FALSE)
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.6\textwidth]{color_files/figure-latex/colorcat-1} 
\hfill
\includegraphics[width=0.28\textwidth]{color_files/figure-latex/colorcont-1}
\caption{Typical usage of color for coding qualitative/categorical (left) and quantiative/continuous (right) information.
Left: Scatter plot of weekly gas consumption by outside temperature before and after installing a house insulation.
Right: Choropleth map of median income in the 16 regions of New Zealand in 2018.
}\label{fig:colorcatcont}
\end{figure}


R provides several ways to specify colors:  by name (e.g., `"red"`);
by hexadecimal RGB code (e.g., `"#FF0000"`); or by integer (e.g., `2`).
When we specify an integer, that provides an index into a 
default set of colors;  the colour `2`
means the second colour in the default set of colours.

However, a more important task than specifying one particular color
is the task of specifying a set of colors to use in combination
with each other.
For example, in the left panel of Figure \ref{fig:colorcatcont}, we need two colors
that are very easily perceived as different from each other. 
In the right panel of Figure \ref{fig:colorcatcont}, we require a set of colors
that appear to change monotonically, e.g., from darker to lighter.

We call this the problem of selecting a good \emph{palette} of colors.
What we need to generate is a vector of R colors, e.g.,
`c("red", "blue")`, `c("#FF0000", "#0000FF")`, or `c(2, 4)`.

# A brief history of R palettes

Early versions of R provided very few functions for choosing colors from readily available palettes. And the palettes
that were provided were standard when they were implemented, but have meanwhile
been widely recognized as being rather poor.  

```{r echo=FALSE}
library(grid)
cellSize <- unit(4, "mm")
ncol <- 10
ns <- 3
gap <- unit(1, "lines")
border <- unit(0, "mm")
bgcol <- "grey80"
bgfill <- "white"
paletteGrid <- function(cols) {
    n <- length(cols)
    nrow <- ceiling(n / ncol)
    pushViewport(viewport(width=ncol*cellSize, height=nrow*cellSize,
                          x=0, y=1,
                          just=c("left", "top")))
    x <- rep((1:ncol - 1)/ncol, nrow)[1:n]
    y <- rep(1 - (1:nrow - 1)/nrow, each=ncol)[1:n]
    grid.rect(x, y, just=c("left", "top"), 
              width=unit(1/ncol, "npc"),
              height=unit(1/nrow, "npc"),
              gp=gpar(fill=cols, lwd=.5))
    upViewport()
}
paletteGrids <- function(colList, nswatch=ns) {
    n <- length(colList)
    nrow <- ceiling(n / nswatch)
    layout <- grid.layout(nrow, nswatch,
                          heights=cellSize + gap,
                          widths=ncol*cellSize + gap,
                          just=c("left", "top"))
    pushViewport(viewport(width=unit(1, "npc") - 2*border,
                          height=unit(1, "npc") - 2*border,
                          layout=layout, name="top"))
    for (i in 1:n) {
        row <- (i-1) %/% nswatch + 1
        col <- (i-1) %% nswatch + 1
        if (!is.null(colList[[i]])) {
            pushViewport(viewport(layout.pos.row=row, layout.pos.col=col))
            grid.text(names(colList)[i], 0, unit(1, "npc") - .5*gap, 
                      just=c("left", "top"),
                      gp=gpar(cex=.7, fontfamily="mono"))
            pushViewport(viewport(y=unit(1, "npc") - gap, just="top"))
            paletteGrid(colList[[i]])
            upViewport(2)
        }
    }
    upViewport()
}
drawBorder <- function(row, y=.5, just="centre",
                       height=unit(1, "npc") + 2*border) {
  pushViewport(viewport(layout.pos.row=row, layout.pos.col=1:3))
  grid.rect(width=unit(1, "npc") + 2*border,
            height=height,
            y=y, just=just,
            gp=gpar(col=bgcol, fill=bgfill),
            name="bg1")
  upViewport()
}
drawBorder <- function(row, 
                       y1=unit(1, "npc") - unit(1, "mm"),
                       y2=unit(0, "npc"),
                       name=NULL) {
  pushViewport(viewport(layout.pos.row=row, layout.pos.col=1:3))
  grid.segments(unit(0, "npc") - border, y1,
                unit(0, "npc") - border, y2,
                gp=gpar(col=bgcol, lwd=7, lineend="butt"),
                name=name)
  upViewport()
}
drawBorder <- function(..., name=NULL) {
  grid.null(name=name)
}
```

  ```{r oldPalettes, echo=FALSE, fig.width=6, fig.height=3, fig.keep="last", out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='Old base R palettes.'}
  paletteGrids(list("palette()"=palette.colors(palette="R3"),
                    "rainbow(8)"=rainbow(8),
                    "blank"=NULL,
                    "blank"=NULL,
                    "blank"=NULL,
                    "blank"=NULL,
                    "heat.colors(8)"=heat.colors(8), 
                    "topo.colors(8)"=topo.colors(8),
                    "terrain.colors(8)"=terrain.colors(8), 
                    "gray.colors(8)"=gray.colors(8),
                    "blank"=NULL,
                    "blank"=NULL,
                    "blank"=NULL,
                    "blank"=NULL,
                    "blank"=NULL,
                    "cm.colors(8)"=cm.colors(8)))
  downViewport("top")
  drawBorder(1, name="bg1")
  drawBorder(3:4, name="bg2")
  drawBorder(6, name="bg3")
  scene <- grid.grab()
  scene <- reorderGrob(scene, c("bg1", "bg2", "bg3"))
  grid.newpage()
  grid.draw(scene)
  ```

The `palette()` function generated a vector of eight colors.
These provided the default
  set of colors that an integer color specification selects from.
  These colors could be used for coding _categorical_ information.

  ```{r eval=FALSE}
  palette()
  ```
  ```{r echo=FALSE}
  palette("R3")
  palette()
  palette("R4")
  ```

  R colour specifications are not particularly readable, so for each
  palette, Figure \ref{fig:oldPalettes}
  represents the vector of R colors by a "swatch"
  of rectangles filled with the corresponding colors.

  The functions `heat.colors()`, `terrain.colors()`, `topo.colors()`, and 
  `gray.colors()` all take an argument `n` to generate that number of colors.
  These colours 
  could be used as _sequential_ palettes for ordered or numeric information.

  The function `cm.colors()` also generates `n` colors.
  These colors could be used as a _diverging_ palette for values that are
  distributed around 
  a "neutral" value, such as zero.

  The function `rainbow()` also generates `n` colors.
  This function implements the infamous rainbow (or "jet") color palette 
  that was very widely used for all types, possibly after restricting 
  the hue range: _categorical_, _sequential_, and _diverging_.

All of these palettes -- except `gray.colors()` -- have poor perceptual properties.
The colors are highly saturated, which can be distracting and overly 
stimulating, 
and the colors are unbalanced with respect to chroma and luminance,
which means that they have unequal visual impact
[@Lonsdale+Lonsdale:2019; @Bartram+Patra+Stone:2017; @Etchebehere+Fedorovskaya:2017]. 
In addition, the palettes do not perform well for viewers with some form
of colorblindness (nearly 10% of the population).
Most of the palettes also use sequences
of hues obtained in the RGB (red-green-blue) space or simple derivations thereof like HSV (hue-saturation-value) or HLS (hue-lightness-saturation),
which leads to clustering of colors at the red, green, and blue primaries.

In R version 2.1.0, Thomas Lumley added the `colorRampPalette()` function.
This makes it easier to generate a palette, though the user is still required
to select, for example, start and end colors from which
a palette of colors can then be interpolated.

Over time, 
better palettes became available via packages on CRAN (Comprehensive R Archive Network)
  starting with \CRANpkg{RColorBrewer} [@RColorBrewer], later
  \CRANpkg{colorspace} [@Ihaka:2003; @Zeileis+Hornik+Murrell:2009], and somewhat more recently
  \CRANpkg{viridis} [@viridis], \CRANpkg{rcartocolor} [@rcartocolor], or \CRANpkg{scico} [@scico],
  among many others.
In addition, higher-level graphics systems
 like \CRANpkg{ggplot2} [@ggplot2] and \CRANpkg{lattice} [@lattice]
developed their own color themes.

These external developments meant that there were no changes to
the palettes provided by the core R graphics system for
a number of years.

```{r oldbase, eval=FALSE, echo=FALSE, fig.height=1.75, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='Old R palette functions.  The label above each swatch shows the function call that produces that set of colors.'}
oldbase.pals <- function() {
  c("default (R3)", "rainbow", paste0(c("heat", "terrain", "topo", "cm", "gray"), ".colors"))
}

oldbase.colors <- function(n, palette = "default", ...) {
  palette <- match.arg(palette, oldbase.pals())
  if(palette == oldbase.pals()[1]) {
    palette.colors(n, palette = "R3", ...)
  } else {
    do.call(palette, list(n = n, ...))
  }
}

oldbase.swatch <- function(palette = oldbase.pals(), n = 8, nrow = 2,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, oldbase.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}

oldbase.swatch()
```

# A new set of R palettes

On the road to R version 4.0.0 an attempt was made to
address the limited and deficient set of palettes that are available 
within the core R graphics sytem and to add
a range of modern color palettes.

## A new default color palette

The default color palette in R -- the default set of colors that can
be specified by integer index -- has been replaced.  The new palette
follows the same basic hues as the old default palette, but
the palette is less saturated overall and
reduces the size of changes in chroma and luminance across the palette.
This produces a calmer and less distracting palette with a more
even visual impact.
An attempt has also been made to improve the discriminability
of the colors in the default palette for colorblind viewers.
The new, "R4", default palette is shown at top-left of Figure 
\ref{fig:newPalettes}.

  ```{r newPalettes, echo=FALSE, fig.width=6, fig.height=4, fig.keep="last", out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='New R palettes available from the `palette.colors()` function.  The label above each swatch shows the argument to provide to `palette.colors()` to produce the set of colors.  The palette at top-left is the new default that is also produced by `palette()`.  The "Okabe-Ito" palette is the default that is produced by `palette.colors()` (with no arguments).'}
  paletteGrids(list('palette="R4"'=palette.colors(palette="R4"),
                    'palette="Okabe-Ito"'=palette.colors(palette="Okabe-Ito"),
                    blank=NULL,
                    blank=NULL,
                    blank=NULL,
                    blank=NULL,
                    'palette="ggplot2"'=palette.colors(palette="ggplot2"),
                    'palette="Tableau 10"'=palette.colors(palette="Tableau 10"),
                    'palette="Classic Tableau"'=palette.colors(palette="Classic Tableau"),
                    blank=NULL,
                    blank=NULL,
                    blank=NULL,
                    'palette="Accent"'=palette.colors(palette="Accent"),
                    'palette="Paired"'=palette.colors(palette="Paired"),
                    'palette="Pastel 1"'=palette.colors(palette="Pastel 1"),
                    'palette="Pastel 2"'=palette.colors(palette="Pastel 2"),
                    'palette="Set 1"'=palette.colors(palette="Set 1"),
                    'palette="Set 2"'=palette.colors(palette="Set 2"),
                    'palette="Set 3"'=palette.colors(palette="Set 3"),
                    'palette="Dark 2"'=palette.colors(palette="Dark 2"),
                    blank=NULL,
                    blank=NULL,
                    blank=NULL,
                    blank=NULL,
                    'palette="Alphabet"'=palette.colors(palette="Alphabet"),
                    'palette="Polychrome 36"'=palette.colors(palette="Polychrome 36")))
  downViewport("top")
  drawBorder(1, name="bg1")
  drawBorder(3, name="bg2")
  drawBorder(5:7, name="bg3")
  drawBorder(9, name="bg4",
             y2=unit(1, "npc") - 4*cellSize - gap)
  scene <- grid.grab()
  scene <- reorderGrob(scene, c("bg1", "bg2", "bg3", "bg4"))
  grid.newpage()
  grid.draw(scene)
  ```

```{r swatch, echo=FALSE}
palette.swatch <- function(palette = palette.pals(), n = 8, nrow = 4,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, palette.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}
```
  ```{r oldvsnew, echo=FALSE, eval=FALSE, fig.width=6, fig.height=1}
  paletteGrids(list('"R3"'=palette.colors(palette="R3"), 
                    '"R4"'=palette.colors(palette="R4")),
               nswatch=1)
  ```

More information about the construction of the new default palette
is given in [@grDevices2].

## The `palette.colors()` function

The `palette.colors()` function, new in R 4.0.0, provides a way to
access several other predefined palettes.  These are shown in
Figure \ref{fig:newPalettes}.

The palettes available via `palette.colors()` are known as 
*qualitative palettes* because they are appropriate for 
encoding qualitative (categorical) variables.  In other words,
these palettes are appropriate for differentiating between groups.

By default `palette.colors()` returns the 
`Okabe-Ito` [@Okabe+Ito:2008] palette.  This palette
 was designed to be very robust under color vision deficiencies, so
the different colors in this palette should be distinguishable
for all viewers. 

  ```{r okabeito, echo=FALSE, eval=FALSE, fig.width=2, fig.height=.5}
  paletteGrids(list("palette.colors()"=palette.colors()))
  ```

The `palette` argument allows us to select a different palette.
For example, the old R default palette is available via the name `"R3"`.
This palette is really only useful to reproduce old behaviour
and remind us how bad things used to be.

  ```{r r3, echo=FALSE, eval=FALSE, fig.width=2, fig.height=.5}
  paletteGrids(list('palette="R3"'=palette.colors(palette="R3")))
  ```

  There are several palettes that have been taken from the color schemes of
  the \pkg{ggplot2} package and Tableau [@Tableau], both 
  well-established graphics systems.  The `"Tableau 10"` palette
  represents the redesign of the default palette in Tableau (CITE!).
  These palettes may be useful
  to emulate the look and feel of plots from those other systems.

  ```{r otherssystems, echo=FALSE, eval=FALSE, fig.width=6, fig.height=.5}
  paletteGrids(list('palette="ggplot2"'=palette.colors(palette="ggplot2"),
                    'palette="Tableau 10"'=palette.colors(palette="Tableau 10"),
                    'palette="Classic Tableau"'=palette.colors(palette="Classic Tableau")))
  ```

  Several palettes come from the ColorBrewer.org [@Harrower+Brewer:2003].
  These palettes were originally designed for filling regions
  on maps, but may also be useful for filling regions within data
  visualisations like bar plots, 
  density plots, and heatmaps.
  

  ```{r colorbrewer, echo=FALSE, eval=FALSE, fig.width=6, fig.height=2}
  paletteGrids(list('palette="Accent"'=palette.colors(palette="Accent"),
                    'palette="Paired"'=palette.colors(palette="Paired"),
                    'palette="Pastel 1"'=palette.colors(palette="Pastel 1"),
                    'palette="Pastel 2"'=palette.colors(palette="Pastel 2"),
                    'palette="Set 1"'=palette.colors(palette="Set 1"),
                    'palette="Set 2"'=palette.colors(palette="Set 2"),
                    'palette="Set 3"'=palette.colors(palette="Set 3"),
                    'palette="Dark 2"'=palette.colors(palette="Dark 2")))
  ```

  Finally, there are two palettes from the 
  \CRANpkg{Polychrome} package [@Polychrome].
  These are much larger palettes, with colours chosen to be evenly
  spread throughout HCL colorspace.  The `"Polychrome 36"` palette
  represents the largest set of colours that could be generated
  while still being visually distinguishable.  The `"Alphabet"`
  palette is just a smaller, but still large, set.  These palettes
  may be useful if you are attempting to represent a very large
  number of categories at once.  The result is unlikely to be
  easy to interpret, but these palettes will be your best chance.
  
  ```{r polychrome, echo=FALSE, eval=FALSE, fig.width=6, fig.height=3}
  paletteGrids(list('palette="Alphabet"'=palette.colors(palette="Alphabet"),
                    'palette="Polychrome 36"'=palette.colors(palette="Polychrome 36")))
  ```

The `palette.pals()` function returns a character vector of 
the available palette names.

```{r}
palette.pals()
```

The first argument to `palette.colors()` is a number of colors.
Each palette has a fixed number of colors, but we can ask for fewer or,
with `recycle = TRUE`, we can get more colors by recycling.

  ```{r recycle, echo=FALSE, fig.width=6, fig.height=3}
  paletteGrids(list('palette.colors(4)'=palette.colors(4),
                    'palette.colors(10, recycle=TRUE)'=palette.colors(10, recycle=TRUE)))
  ```

Each of these palettes can be set as the default palette by passing
the palette name to the `palette()` function.  For example,
the following code sets the Okabe-Ito palette as the default palette.

```{r}
palette("Okabe-Ito")
```

## The `hcl.colors()` function



\newpage

 base R was finally overcome by introducing two new palette functions:

- `palette.colors()` provides a new improved default color palette as well as a few other well-established qualitative palettes [@grDevices2]
- `hcl.colors()` provides a wide range of qualitative, sequential, and diverging palettes obtained by a standardized approach in
  the so-called HCL (hue-chroma-luminance) space [@Wiki+HCL], see @grDevices and @Zeileis+Fisher+Hornik:2020.
  Most of these HCL palettes approximate very closely well-established palettes from \pkg{RColorBrewer}, \pkg{viridis}, \pkg{rcartocolor},
  \pkg{scico}, and others.

Both are accompanied by functions to query the available palette names (`palette.pals()` and `hcl.pals()`, respectively).
The color swatches shown in Figures \ref{fig:palette}, \ref{fig:hcls}, and \ref{fig:hcld} which are also shown by running
the `example()` of the two functions which make basic `palette.swatch()` and `hcl.swatch()` functions available.
Here, focus on `palette.colors()`, more details on `hcl.colors()` later.

```{r palette, echo=FALSE, fig.height=3.5, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{palette.colors()}.'}
## height=5, width=12
palette.swatch()
```

Briefly explain principles for selection of `R4` (similar hues, limited differences in chroma/luminance, dark/colorful, work ok for colorblind viewers).
`Okabe-Ito` [@Okabe+Ito:2008] was designed to be very robust under color vision deficiencies. As it uses somewhat different hues than the old `R4` palette
and was hence not used as the new default palette in R but it is the default in `palette.colors()`.
The robustness of both palettes is illustrated in Figure \ref{fig:cvd}.

```{r cvd, echo=FALSE, fig.height=3.5, fig.width=12, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Color vision deficiency emulation for \\code{R4} (left) and \\code{Okabe-Ito} (right) palettes.'}
layout(rbind(1:2), widths = c(0.46, 0.54))
swatchplot(palette.colors(palette = "R4"), cvd = TRUE)
swatchplot(palette.colors(palette = "Okabe-Ito"), cvd = TRUE)
```

The other palettes are from well-established software packages like \pkg{ggplot2} [@ggplot2], ColorBrewer.org [@Harrower+Brewer:2003],
or Tableau [@Tableau]. Moreover, two palettes with many colors (36 and 26, respectively) are used from the
\CRANpkg{Polychrome} package [@Polychrome].

## Illustration

Show usage of new qualitative palettes in practice. Consider:
Power of color often overestimated.
Color vision deficiencies ($\sim 8$% of male and $\sim 0.5$% of female viewers).
Other physical or technical limitations.

Starting point: Time series line plot using base graphics, see Figure \ref{fig:tsplot} (top left), essentially:

```{r tsplot-pseudocode, eval=FALSE}
p <- c(1:3, 5)
plot(EuStockMarkets, log = "y", plot.type = "single", col = p, ...)
legend("topleft", colnames(EuStockMarkets), col = p, ...)
```

The first two rows show the old default colors from R 3.x.y and the new default colors startin from R 4.0.0.
Additionally, the figure uses @Okabe+Ito:2008 palette and it switches from a color legend to direct labeling.

In the right column: Emulation of a kind of red-green
color blindness known as protanopia using the \pkg{colorspace} package based on
the algorithms of @Machado+Oliveira+Fernandes:2009.

```{r tsplot, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Time series line plot of \\code{EuStockMarkets}. Rows: Old \\code{"R3"} default palette (top), new \\code{"R4"} default palette (middle), \\code{"OkabeIto"} palette (bottom), designed to be robust under color vision deficiencies. Columns: Normal vision (left) and emulated protanope vision (right). A color legend is used in the first row and direct labels in the other rows.'}
tsplot <- function(palette = "R3", protan = FALSE, legend = TRUE, ...) {
  ## color palette
  palette <- match.arg(palette, c("R3", "R4", "Okabe-Ito"))
  p <- switch(palette,
    "R3" = palette.colors(8, "R3")[c(1:3, 5)],
    "R4" = palette.colors(8, "R4")[c(1:3, 5)],
    "Okabe-Ito" = palette.colors(4, "Okabe-Ito")[c(1, 4, 2, 3)]
  )
  
  ## emulate protanope vision?
  if(protan) p <- colorspace::protan(p) 
  
  ## time series plot
  eu <- window(EuStockMarkets, end = 1998)
  plot(eu, log = "y", ylab = "EU Stock Prices", plot.type = "single", col = p, xlim = c(1991.6, 1998.4), lwd = 1.5, ...)
  text(1991.3, 6000, palette, pos = 4, cex = 1.5)

  ## legend or direct labeling
  if(legend) {
    legend(1991.3, 6000, colnames(eu), col = p, lty = 1, lwd = 3, bty = "n")
  } else {
    text(1998, tail(eu, 1), colnames(eu), pos = 4, col = p, xpd = TRUE)
  }
  
  invisible(p)
}

par(mfrow = c(3, 2), mar = c(5, 4, 2, 1))
tsplot(palette = "R3", protan = FALSE, legend = TRUE, main = "Normal")
tsplot(palette = "R3", protan = TRUE, legend = TRUE, main = "Protanope")
par(mar = c(5, 4, 1, 1))
tsplot(palette = "R4", protan = FALSE, legend = FALSE)
tsplot(palette = "R4", protan = TRUE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = FALSE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = TRUE, legend = FALSE)
```

Old `R3` default palette: Too flashy, cyan too light, hard to distinguish for protanope viewers.
The colors for the German stock index DAX and the Swiss stock index SMI look almost identical to protanope viewers.

New `R4` default palette: Similar hues, more balanced brightness, avoid garish colors, distinguishable for viewers with color vision deficiencies. Cyan much better.

`Okabe-Ito`: Even easier to distinguish.


# HCL-based color palettes

## Construction principles

HCL makes it easy to describe colors for humans, using the three basic properties hue, chroma, and luminance (see Figure \ref{fig:hcl}).

```{r hcl, echo=FALSE, fig.height=2.4, fig.width=5, out.width='0.4\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Varying hue, chroma, and luminance separately, keeping the other two properties fixed.'}
swatchplot(
  "Hue\n(Type of color)"    = sequential_hcl(5, h = c(0, 300), c = c(60, 60), l = 65),
  "Chroma\n(Colorfulness)"  = sequential_hcl(5, h = 0, c = c(100, 0), l = 65, rev = TRUE, power = 1),
  "Luminance\n(Brightness)" = sequential_hcl(5, h = 260, c = c(25, 25), l = c(25, 90), rev = TRUE, power = 1),
  nrow = 3, line = 8, off = 0
)
```

For qualitative palettes mainly vary hue. Completely balanced if chroma and luminance kept fixed which
was suggested by @Ihaka:2003 and is implemented in `hcl.colors()`. See left panel of Figure \ref{fig:hclpal}
and Figure \ref{fig:hclq}.
Two drawbacks: Relatively few colors that can be clearly distinguished (about six), even fewer under
color vision deficiencies (about three). Hence in most situations better allow limited variations in chroma and luminance
as in `palette.colors()`. No general HCL-based strategy for such palettes.

```{r hclpal, echo=FALSE, fig.height=2.4, fig.width=15, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Basic idea for HCL palettes.'}
swatchplot(
  "Qualitative (Set 2)"     = rbind("Color" = hcl.colors(5, "Set 2"),     "Desaturated" = desaturate(hcl.colors(5, "Set 2"))),
  "Sequential (Blues)"    = rbind("Color" = hcl.colors(7, "Blues"),    "Desaturated" = desaturate(hcl.colors(7, "Blues"))),
  "Diverging (Green-Brown)" = rbind("Color" = hcl.colors(7, "Green-Brown"), "Desaturated" = desaturate(hcl.colors(7, "Green-Brown"))),
  nrow = 3, off = 0, line = 7
)
```
For sequential and diverging palettes monotonic changes in luminance are most important (see middle and right panel
in Figure \ref{fig:hclpal}). Add changes in chroma and possibly also hue (see Figure \ref{fig:specplot}).
`Blues 2` uses a constant hue and monotonic changes in chroma and luminance going from dark and colorful blue to
light gray. `Blues` uses similar luminance trajectory, slightly varies hue, and has triangular chroma curve (rather
than monotonic). `Blues 2` mostly emphasizes the dark and colorful blue while `Blues` makes the colors more easily
distinguishable in the middle.

Diverging combines two sequential, making both arms as balanced as possible.


```{r specplot, echo=TRUE, fig.height=5, fig.width=5, fig.show='hide'}
specplot(hcl.colors(7, "Blues"), hcl.colors(7, "Blues 2"))
specplot(hcl.colors(7, "Green-Brown"))
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-1} 
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-2}
\caption{Spectrum of luminance (blue, left axis), chroma (green, left axis), and hue (red, right axis) trajectories.
Left: Sequential \code{Blues} (solid) and \code{Blues 2} (dashed) palettes.
Right: Diverging \code{Green-Brown} palette.}\label{fig:specplot}
\end{figure}


## Available palettes

Overview of qualitative (Figure \ref{fig:hclq}), sequential (Figure \ref{fig:hcls}), and diverging (Figure \ref{fig:hcld})
palettes based on HCL principles. Many closely approximate colors from ColorBrewer.org, CARTO Color, Viridis, and 
Crameri's scientific colors. See <http://colorspace.R-Forge.R-project.org/articles/approximations.html> for one-to-one
comparisons.

```{r hclq, echo=FALSE, fig.height=2, fig.width=8, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{hcl.colors()}.'}
hcl.swatch <- function(palette = NULL, type = NULL, n = 5, nrow = 11,
  border = if (n < 15) "black" else NA, ...) {
    if(is.null(palette)) palette <- hcl.pals(type)
    cols <- sapply(palette, hcl.colors, n = n)
    ncol <- ncol(cols)
    nswatch <- min(ncol, nrow)

    par(mar = rep(0.1, 4),
        mfrow = c(1, min(6, ceiling(ncol/nrow))),
        cex = 0.7, ...)

    while (length(palette)) {
        subset <- 1:min(nrow, ncol(cols))
        plot.new()
        plot.window(c(0, n), c(0, nrow + 1))
        text(0, rev(subset) + 0.1, palette[subset], adj = c(0, 0))
        y <- rep(subset, each = n)
        rect(rep(0:(n-1), n), rev(y), rep(1:n, n), rev(y) - 0.5,
             col = cols[, subset], border = border)
        palette <- palette[-subset]
        cols <- cols[, -subset, drop = FALSE]
    }

    par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), cex = 1)
}

hcl.swatch(type = "qualitative", nrow = 2)
```

```{r hcls, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Sequential palettes from \\code{hcl.colors()}.'}
hcl.swatch(type = "sequential", nrow = 12)
```

```{r hcld, echo=FALSE, fig.height=4.5, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Diverging palettes from \\code{hcl.colors()}.'}
hcl.swatch(c(hcl.pals("diverging"), hcl.pals("divergingx")), nrow = 6)
```

## Illustration

Risk maps: Communication to the public particularly important.

Example: Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04, during hurricane Dorian.

Source: National Oceanic and Atmospheric Administration.

Original: Works poorly because too much chroma everywhere and non-monotonic luminance (dark to light and back to dark).
Extremely hard to read for colorblind viewers (see Figure \ref{fig:dorian}).

Better HCL-based alternative: `OrRd` and also merging some probability intervals to make matching of intervals to colors easier, still clearly conveys overall shape.

Might have contributed to Trump's confusion in "Sharpiegate" incident. See @Zeileis+Stauffer:2019 for a more detailed discussion and other alternative color palettes.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig-deutan.png} 

\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd-deutan.png} 
\caption{Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04..}\label{fig:dorian}
\end{figure}




# New defaults in graphical functions

Many graphics functions have now slightly different default output, namely when they are using colors `2`, `3`, `4`, etc. but still red, green, blue.

Moreover, a couple of functions explicitly have new defauls, namely: `image()` and `filled.contour()`, now using sequential `YlOrRd` palette
(from ColorBrewer) which uses similar hues as the old `heat.colors()`. See Figure \ref{fig:graphics}.

Finally, it might be worth mentioning that `hist()` and `boxplot()` (and thus `plot(num ~ factor, ...)`) have a new default color:
light gray which makes it a bit easier to compare the shaded areas.

```{r graphics, echo=-1, fig.height=4, fig.width=14, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='New defaults in base graphics.'}
par(mfrow = c(1, 3))
image(volcano)
boxplot(weight ~ feed, data = chickwts)
hist(chickwts$weight)
```


