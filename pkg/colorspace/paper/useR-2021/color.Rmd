---
title: Coloring in R's Blind Spot
author:
  # see ?rjournal_article for more information
  - name: Achim Zeileis
    affiliation: UniversitÃ¤t Innsbruck
    address:
    - Department of Statistics
    url: https://www.zeileis.org/
    orcid: 0000-0003-0918-3766
    email:  Achim.Zeileis@R-project.org
  - name: Paul Murrell
    affiliation: University of Auckland
    address:
    - Department of Statistics
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
    email:  paul@stat.auckland.ac.nz
abstract: >
  Starting from R 4.0.0 R has a new and much improved default palette.
  More than 100 well-established palettes provided in `palette.colors()` and `hcl.colors()`.
  Overview and guidance.  
  **Meta:**
  Abstract must not have more than 150 words.
  File name of tex and bib should be the same.
  Compile document with `rmarkdown::render("color.Rmd")`.
  More details at <https://journal.R-project.org/share/author-guide.pdf>.  
preamble: |
  \newcommand{\doi}[1]{\href{https://doi.org/#1}{\normalfont\texttt{doi:\discretionary{}{}{}{#1}}}}
bibliography: color.bib
output: rticles::rjournal_article
---

```{r preliminaries, include = FALSE}
library("colorspace")
```

# Introduction

Color can be a very effective way to distinguish between different groups
within a data visualisation.  Color is a "preattentive" visual feature,
meaning that groups are identified rapidly and without conscious effort
[@Ware:2012].

```{r colorcat, echo=FALSE, fig.height=3, fig.width=5, out.width='.6\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='A placeholder for a scatterplot that has two groups of points and it is REALLY easy to see that there are two groups and which points belong to which group.'}
library("ggplot2")
data("whiteside", package = "MASS")
ggplot(whiteside) +
    geom_point(aes(Temp, Gas, color = Insul), size = 2) +
    ggtitle("PLACE HOLDER") +
    theme(legend.position = "none") +
    theme_minimal()
```

Employing
 color to represent values on a continuous numeric scale will be less successful
[@Cleveland+McGill:1984], but color can
still be useful to convey additional variables when more effective
visual features, such as location, have already been used.  For example,
color might be used to fill in different regions on a map.

```{r colorcont, echo=FALSE, fig.height=5, fig.width=7, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='A placeholder for a choropleth map.'}
library("maps")
crimes <- data.frame(state = tolower(rownames(USArrests)), USArrests)
vars <- lapply(names(crimes)[-1], 
               function(j) {
                   data.frame(state = crimes$state, variable = j, 
                   value = crimes[[j]])
               })
crimes_long <- do.call("rbind", vars)
states_map <- map_data("state")
ggplot(crimes, aes(map_id = state)) +
    geom_map(aes(fill = Murder), map = states_map) +
    expand_limits(x = states_map$long, y = states_map$lat) +
    ggtitle("PLACE HOLDER") +
    coord_fixed() +
    theme_minimal()
```

R provides several ways to specify colors:  by name, e.g., `"red"`;
by hexadecimal RGB code, e.g., `"#FF0000"`; or by integer.
An integer specification provides an index into a "palette",
with a default set of palette colors provided.
However, this leaves the problem of selecting a good palette; 
a sensible, effective, and appropriate set of colours.

## History of R palettes

Early versions of R provided very few functions for choosing colors from readily available palettes. And the palettes
that were provided (see Figure \ref{fig:oldbase}) were standard when they were implemented but have meanwhile
been widely recognized as being rather poor.

- The colors from the default `palette()`, accessed through numbers `1` to `8`,
could be used for coding _categorical_ information.
- The functions `heat.colors()`, `terrain.colors()`, `topo.colors()`, and `gray.colors()` could be used as _sequential_ palettes for ordered or numeric information.
- The function `cm.colors()` provided a _diverging_ palette for values that are
distributed around 
a "neutral" value, such as zero.
- The function `rainbow()` implements the infamous rainbow (or jet) color palette that was very widely used for all types, possibly after restricting the hue range: _categorical_, _sequential_, and _diverging_.

```{r oldbase, echo=FALSE, fig.height=1.75, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Old base R palettes.'}
oldbase.pals <- function() {
  c("default (R3)", "rainbow", paste0(c("heat", "terrain", "topo", "cm", "gray"), ".colors"))
}

oldbase.colors <- function(n, palette = "default", ...) {
  palette <- match.arg(palette, oldbase.pals())
  if(palette == oldbase.pals()[1]) {
    palette.colors(n, palette = "R3", ...)
  } else {
    do.call(palette, list(n = n, ...))
  }
}

oldbase.swatch <- function(palette = oldbase.pals(), n = 8, nrow = 2,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, oldbase.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}

oldbase.swatch()
```

All of these palettes -- except `gray.colors()` -- have poor perceptual properties.
The colors are highly saturated, which can be distracting and overly 
stimulating 
and the colors are unbalanced with respect to chroma and luminance,
which means that they have unequal visual impact
[@Lonsdale+Lonsdale:2019; @Bartram+Patra+Stone:2017; @Etchebehere+Fedorovskaya:2017]. 
The palettes do not perform well for viewers with some form
of colorblindness (nearly 10% of the population).
Most of the palettes also use sequences
of hues obtained in the RGB (red-green-blue) space or simple derivations thereof like HSV (hue-saturation-value) or HLS (hue-lightness-saturation).
This leads to clustering of colors at the red, green, and blue primaries.

Better color palettes had been neglected in base R for a long time. There are various reasons for this:

- Functions like `colorRampPalette()` allowed users to create new palettes on the fly -- provided they had useful colors available upon which
  the palette could be based.
- Better palettes were easily available in packages on CRAN (Comprehensive R Archive Network)
  starting with \CRANpkg{RColorBrewer} [@RColorBrewer], later
  \CRANpkg{colorspace} [@Ihaka:2003; @Zeileis+Hornik+Murrell:2009], and somewhat more recently
  \CRANpkg{viridis} [@viridis], \CRANpkg{rcartocolor} [@rcartocolor], or \CRANpkg{scico} [@scico],
  among many others.
- Instead of using base graphics, frameworks like \CRANpkg{ggplot2} [@ggplot2] or \CRANpkg{lattice} [@lattice]
  which bring along their own color themes were adopted very widely.


## New base R palettes

On the road to R version 4.0.0 this deficit of base R was finally overcome by introducing two new palette functions:

- `palette.colors()` provides a new improved default color palette as well as a few other well-established qualitative palettes [@grDevices2]
- `hcl.colors()` provides a wide range of qualitative, sequential, and diverging palettes obtained by a standardized approach in
  the so-called HCL (hue-chroma-luminance) space [@Wiki+HCL], see @grDevices and @Zeileis+Fisher+Hornik:2020.
  Most of these HCL palettes approximate very closely well-established palettes from \pkg{RColorBrewer}, \pkg{viridis}, \pkg{rcartocolor},
  \pkg{scico}, and others.

Both are accompanied by functions to query the available palette names (`palette.pals()` and `hcl.pals()`, respectively).
The color swatches shown in Figures \ref{fig:palette}, \ref{fig:hcls}, and \ref{fig:hcld} which are also shown by running
the `example()` of the two functions which make basic `palette.swatch()` and `hcl.swatch()` functions available.
Here, focus on `palette.colors()`, more details on `hcl.colors()` later.

```{r palette, echo=FALSE, fig.height=3.5, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{palette.colors()}.'}
palette.swatch <- function(palette = palette.pals(), n = 8, nrow = 4,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, palette.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}

## height=5, width=12
palette.swatch()
```

Briefly explain principles for selection of `R4` (similar hues, limited differences in chroma/luminance, dark/colorful, work ok for colorblind viewers).
`Okabe-Ito` [@Okabe+Ito:2008] was designed to be very robust under color vision deficiencies. As it uses somewhat different hues than the old `R4` palette
and was hence not used as the new default palette in R but it is the default in `palette.colors()`.
The robustness of both palettes is illustrated in Figure \ref{fig:cvd}.

```{r cvd, echo=FALSE, fig.height=3.5, fig.width=12, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Color vision deficiency emulation for \\code{R4} (left) and \\code{Okabe-Ito} (right) palettes.'}
layout(rbind(1:2), widths = c(0.46, 0.54))
swatchplot(palette.colors(palette = "R4"), cvd = TRUE)
swatchplot(palette.colors(palette = "Okabe-Ito"), cvd = TRUE)
```

The other palettes are from well-established software packages like \pkg{ggplot2} [@ggplot2], ColorBrewer.org [@Harrower+Brewer:2003],
or Tableau [@Tableau]. Moreover, two palettes with many colors (36 and 26, respectively) are used from the
\CRANpkg{Polychrome} package [@Polychrome].

## Illustration

Show usage of new qualitative palettes in practice. Consider:
Power of color often overestimated.
Color vision deficiencies ($\sim 8$% of male and $\sim 0.5$% of female viewers).
Other physical or technical limitations.

Starting point: Time series line plot using base graphics, see Figure \ref{fig:tsplot} (top left), essentially:

```{r tsplot-pseudocode, eval=FALSE}
p <- c(1:3, 5)
plot(EuStockMarkets, log = "y", plot.type = "single", col = p, ...)
legend("topleft", colnames(EuStockMarkets), col = p, ...)
```

The first two rows show the old default colors from R 3.x.y and the new default colors startin from R 4.0.0.
Additionally, the figure uses @Okabe+Ito:2008 palette and it switches from a color legend to direct labeling.

In the right column: Emulation of a kind of red-green
color blindness known as protanopia using the \pkg{colorspace} package based on
the algorithms of @Machado+Oliveira+Fernandes:2009.

```{r tsplot, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Time series line plot of \\code{EuStockMarkets}. Rows: Old \\code{"R3"} default palette (top), new \\code{"R4"} default palette (middle), \\code{"OkabeIto"} palette (bottom), designed to be robust under color vision deficiencies. Columns: Normal vision (left) and emulated protanope vision (right). A color legend is used in the first row and direct labels in the other rows.'}
tsplot <- function(palette = "R3", protan = FALSE, legend = TRUE, ...) {
  ## color palette
  palette <- match.arg(palette, c("R3", "R4", "Okabe-Ito"))
  p <- switch(palette,
    "R3" = palette.colors(8, "R3")[c(1:3, 5)],
    "R4" = palette.colors(8, "R4")[c(1:3, 5)],
    "Okabe-Ito" = palette.colors(4, "Okabe-Ito")[c(1, 4, 2, 3)]
  )
  
  ## emulate protanope vision?
  if(protan) p <- colorspace::protan(p) 
  
  ## time series plot
  eu <- window(EuStockMarkets, end = 1998)
  plot(eu, log = "y", ylab = "EU Stock Prices", plot.type = "single", col = p, xlim = c(1991.6, 1998.4), lwd = 1.5, ...)
  text(1991.3, 6000, palette, pos = 4, cex = 1.5)

  ## legend or direct labeling
  if(legend) {
    legend(1991.3, 6000, colnames(eu), col = p, lty = 1, lwd = 3, bty = "n")
  } else {
    text(1998, tail(eu, 1), colnames(eu), pos = 4, col = p, xpd = TRUE)
  }
  
  invisible(p)
}

par(mfrow = c(3, 2), mar = c(5, 4, 2, 1))
tsplot(palette = "R3", protan = FALSE, legend = TRUE, main = "Normal")
tsplot(palette = "R3", protan = TRUE, legend = TRUE, main = "Protanope")
par(mar = c(5, 4, 1, 1))
tsplot(palette = "R4", protan = FALSE, legend = FALSE)
tsplot(palette = "R4", protan = TRUE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = FALSE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = TRUE, legend = FALSE)
```

Old `R3` default palette: Too flashy, cyan too light, hard to distinguish for protanope viewers.
The colors for the German stock index DAX and the Swiss stock index SMI look almost identical to protanope viewers.

New `R4` default palette: Similar hues, more balanced brightness, avoid garish colors, distinguishable for viewers with color vision deficiencies. Cyan much better.

`Okabe-Ito`: Even easier to distinguish.


# HCL-based color palettes

## Construction principles

HCL makes it easy to describe colors for humans, using the three basic properties hue, chroma, and luminance (see Figure \ref{fig:hcl}).

```{r hcl, echo=FALSE, fig.height=2.4, fig.width=5, out.width='0.4\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Varying hue, chroma, and luminance separately, keeping the other two properties fixed.'}
swatchplot(
  "Hue\n(Type of color)"    = sequential_hcl(5, h = c(0, 300), c = c(60, 60), l = 65),
  "Chroma\n(Colorfulness)"  = sequential_hcl(5, h = 0, c = c(100, 0), l = 65, rev = TRUE, power = 1),
  "Luminance\n(Brightness)" = sequential_hcl(5, h = 260, c = c(25, 25), l = c(25, 90), rev = TRUE, power = 1),
  nrow = 3, line = 8, off = 0
)
```

For qualitative palettes mainly vary hue. Completely balanced if chroma and luminance kept fixed which
was suggested by @Ihaka:2003 and is implemented in `hcl.colors()`. See left panel of Figure \ref{fig:hclpal}
and Figure \ref{fig:hclq}.
Two drawbacks: Relatively few colors that can be clearly distinguished (about six), even fewer under
color vision deficiencies (about three). Hence in most situations better allow limited variations in chroma and luminance
as in `palette.colors()`. No general HCL-based strategy for such palettes.

```{r hclpal, echo=FALSE, fig.height=2.4, fig.width=15, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Basic idea for HCL palettes.'}
swatchplot(
  "Qualitative (Set 2)"     = rbind("Color" = hcl.colors(5, "Set 2"),     "Desaturated" = desaturate(hcl.colors(5, "Set 2"))),
  "Sequential (Blues)"    = rbind("Color" = hcl.colors(7, "Blues"),    "Desaturated" = desaturate(hcl.colors(7, "Blues"))),
  "Diverging (Green-Brown)" = rbind("Color" = hcl.colors(7, "Green-Brown"), "Desaturated" = desaturate(hcl.colors(7, "Green-Brown"))),
  nrow = 3, off = 0, line = 7
)
```
For sequential and diverging palettes monotonic changes in luminance are most important (see middle and right panel
in Figure \ref{fig:hclpal}). Add changes in chroma and possibly also hue (see Figure \ref{fig:specplot}).
`Blues 2` uses a constant hue and monotonic changes in chroma and luminance going from dark and colorful blue to
light gray. `Blues` uses similar luminance trajectory, slightly varies hue, and has triangular chroma curve (rather
than monotonic). `Blues 2` mostly emphasizes the dark and colorful blue while `Blues` makes the colors more easily
distinguishable in the middle.

Diverging combines two sequential, making both arms as balanced as possible.


```{r specplot, echo=TRUE, fig.height=5, fig.width=5, fig.show='hide'}
specplot(hcl.colors(7, "Blues"), hcl.colors(7, "Blues 2"))
specplot(hcl.colors(7, "Green-Brown"))
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-1} 
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-2}
\caption{Spectrum of luminance (blue, left axis), chroma (green, left axis), and hue (red, right axis) trajectories.
Left: Sequential \code{Blues} (solid) and \code{Blues 2} (dashed) palettes.
Right: Diverging \code{Green-Brown} palette.}\label{fig:specplot}
\end{figure}


## Available palettes

Overview of qualitative (Figure \ref{fig:hclq}), sequential (Figure \ref{fig:hcls}), and diverging (Figure \ref{fig:hcld})
palettes based on HCL principles. Many closely approximate colors from ColorBrewer.org, CARTO Color, Viridis, and 
Crameri's scientific colors. See <http://colorspace.R-Forge.R-project.org/articles/approximations.html> for one-to-one
comparisons.

```{r hclq, echo=FALSE, fig.height=2, fig.width=8, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{hcl.colors()}.'}
hcl.swatch <- function(palette = NULL, type = NULL, n = 5, nrow = 11,
  border = if (n < 15) "black" else NA, ...) {
    if(is.null(palette)) palette <- hcl.pals(type)
    cols <- sapply(palette, hcl.colors, n = n)
    ncol <- ncol(cols)
    nswatch <- min(ncol, nrow)

    par(mar = rep(0.1, 4),
        mfrow = c(1, min(6, ceiling(ncol/nrow))),
        cex = 0.7, ...)

    while (length(palette)) {
        subset <- 1:min(nrow, ncol(cols))
        plot.new()
        plot.window(c(0, n), c(0, nrow + 1))
        text(0, rev(subset) + 0.1, palette[subset], adj = c(0, 0))
        y <- rep(subset, each = n)
        rect(rep(0:(n-1), n), rev(y), rep(1:n, n), rev(y) - 0.5,
             col = cols[, subset], border = border)
        palette <- palette[-subset]
        cols <- cols[, -subset, drop = FALSE]
    }

    par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), cex = 1)
}

hcl.swatch(type = "qualitative", nrow = 2)
```

```{r hcls, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Sequential palettes from \\code{hcl.colors()}.'}
hcl.swatch(type = "sequential", nrow = 12)
```

```{r hcld, echo=FALSE, fig.height=4.5, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Diverging palettes from \\code{hcl.colors()}.'}
hcl.swatch(c(hcl.pals("diverging"), hcl.pals("divergingx")), nrow = 6)
```

## Illustration

Risk maps: Communication to the public particularly important.

Example: Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04, during hurricane Dorian.

Source: National Oceanic and Atmospheric Administration.

Original: Works poorly because too much chroma everywhere and non-monotonic luminance (dark to light and back to dark).
Extremely hard to read for colorblind viewers (see Figure \ref{fig:dorian}).

Better HCL-based alternative: `OrRd` and also merging some probability intervals to make matching of intervals to colors easier, still clearly conveys overall shape.

Might have contributed to Trump's confusion in "Sharpiegate" incident. See @Zeileis+Stauffer:2019 for a more detailed discussion and other alternative color palettes.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig-deutan.png} 

\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd-deutan.png} 
\caption{Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04..}\label{fig:dorian}
\end{figure}




# New defaults in graphical functions

Many graphics functions have now slightly different default output, namely when they are using colors `2`, `3`, `4`, etc. but still red, green, blue.

Moreover, a couple of functions explicitly have new defauls, namely: `image()` and `filled.contour()`, now using sequential `YlOrRd` palette
(from ColorBrewer) which uses similar hues as the old `heat.colors()`. See Figure \ref{fig:graphics}.

Finally, it might be worth mentioning that `hist()` and `boxplot()` (and thus `plot(num ~ factor, ...)`) have a new default color:
light gray which makes it a bit easier to compare the shaded areas.

```{r graphics, echo=-1, fig.height=4, fig.width=14, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='New defaults in base graphics.'}
par(mfrow = c(1, 3))
image(volcano)
boxplot(weight ~ feed, data = chickwts)
hist(chickwts$weight)
```


