---
title: Coloring in R's Blind Spot
author:
  # see ?rjournal_article for more information
  - name: Achim Zeileis
    affiliation: UniversitÃ¤t Innsbruck
    address:
    - Department of Statistics
    url: https://www.zeileis.org/
    orcid: 0000-0003-0918-3766
    email:  Achim.Zeileis@R-project.org
  - name: Paul Murrell
    affiliation: University of Auckland
    address:
    - Department of Statistics
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
    email:  paul@stat.auckland.ac.nz
abstract: >
  Starting from R 4.0.0 R has a new and much improved default palette.
  More than 100 well-established palettes provided in `palette.colors()` and `hcl.colors()`.
  Overview and guidance.  
  **Meta:**
  Abstract must not have more than 150 words.
  File name of tex and bib should be the same.
  Compile document with `rmarkdown::render("color.Rmd")`.
  More details at <https://journal.R-project.org/share/author-guide.pdf>.  
preamble: |
  \newcommand{\doi}[1]{\href{https://doi.org/#1}{\normalfont\texttt{doi:\discretionary{}{}{}{#1}}}}
bibliography: color.bib
output: rticles::rjournal_article
---

```{r preliminaries, include = FALSE}
library("colorspace")
```

# Introduction

Color can be a very effective way to distinguish between different groups
within a data visualization.  Color is a "preattentive" visual feature,
meaning that groups are identified rapidly and without conscious effort
[@Ware:2012].
Employing color to represent values on a continuous numeric scale will be
less successful [@Cleveland+McGill:1984], but color can
still be useful to convey additional variables when more effective
visual features, such as location, have already been used.  For example,
color might be used to fill in different regions on a map.

```{r colorcat, echo=FALSE, fig.height=4, fig.width=6, fig.show = 'hide'}
library("ggplot2")
data("whiteside", package = "MASS")
ggplot(whiteside, aes(Temp, Gas, color = Insul)) +
    geom_point(size = 2) +
    scale_color_manual(name = "Insulation", values = palette.colors(palette = "R4")[c(2, 4)]) +
    ggtitle("Whiteside's data") + xlab("Outside temperature") + ylab("Gas consumption") +
    theme(legend.position = "none") +
    theme_minimal()
```

```{r colorcont, echo=FALSE, fig.height=4, fig.width=3, fig.show = 'hide'}
library("tmap")
data("nz", package = "spData")
myfun <- function(x) {
  y <- format(round(x), big.mark = ",")
  z <- grepl("0,000", y, fixed = TRUE) | grepl("5,000", y, fixed = TRUE)
  z[range(seq_along(x))] <- TRUE
  y[!z] <- ""
  return(y)
}
tm_shape(nz) +
  tm_polygons(col = "Median_income",
    palette = "Blues", style = "cont", breaks = seq(20, 35, by = 5/3) * 1000,
    title = "Median income",
    legend.format = list(fun = myfun)) +
  tm_layout(frame = FALSE)
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.6\textwidth]{color_files/figure-latex/colorcat-1} 
\hfill
\includegraphics[width=0.28\textwidth]{color_files/figure-latex/colorcont-1}
\caption{Typical usage of color for coding qualitative/categorical (left) and quantiative/continuous (right) information.
Left: Scatter plot of weekly gas consumption by outside temperature before and after installing a house insulation.
Right: Choropleth map of median income in the 16 regions of New Zealand in 2018.
}\label{fig:colorcatcont}
\end{figure}


R provides several ways to specify colors:  by name (e.g., `"red"`);
by hexadecimal RGB code (e.g., `"#FF0000"`); or by integer (e.g., `2`).
When we specify an integer, that provides an index into a "palette",
with a default set of palette colors provided.

```{r eval=FALSE}
palette()
```
```{r echo=FALSE}
print(palette("R3"))
```

However, a more important task than specifying one particular color
is the task of specifying a set of colors to use in combination
with each other.
For example, in the left panel of Figure \ref{fig:colorcatcont}, we need two colors
that are very easily perceived as different from each other. 
In the right panel of Figure \ref{fig:colorcatcont}, we require a large set of colors
that appear to change monotonically, e.g., from darker to lighter.
We call this the problem of selecting a good \emph{palette} of colors.

# A brief history of R palettes

Early versions of R provided very few functions for choosing colors from readily available palettes. And the palettes
that were provided (see Figure \ref{fig:oldbase}) were standard when they were implemented, but have meanwhile
been widely recognized as being rather poor.

- The colors from the default `palette()`, accessed through numbers `1` to `8`,
could be used for coding _categorical_ information.
- The functions `heat.colors()`, `terrain.colors()`, `topo.colors()`, and `gray.colors()` could be used as _sequential_ palettes for ordered or numeric information.
- The function `cm.colors()` provided a _diverging_ palette for values that are
distributed around 
a "neutral" value, such as zero.
- The function `rainbow()` implements the infamous rainbow (or jet) color palette that was very widely used for all types, possibly after restricting the hue range: _categorical_, _sequential_, and _diverging_.

```{r oldbase, echo=FALSE, fig.height=1.75, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='t!', fig.cap='Old base R palettes.'}
oldbase.pals <- function() {
  c("default (R3)", "rainbow", paste0(c("heat", "terrain", "topo", "cm", "gray"), ".colors"))
}

oldbase.colors <- function(n, palette = "default", ...) {
  palette <- match.arg(palette, oldbase.pals())
  if(palette == oldbase.pals()[1]) {
    palette.colors(n, palette = "R3", ...)
  } else {
    do.call(palette, list(n = n, ...))
  }
}

oldbase.swatch <- function(palette = oldbase.pals(), n = 8, nrow = 2,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, oldbase.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}

oldbase.swatch()
```

All of these palettes -- except `gray.colors()` -- have poor perceptual properties.
The colors are highly saturated, which can be distracting and overly 
stimulating, 
and the colors are unbalanced with respect to chroma and luminance,
which means that they have unequal visual impact
[@Lonsdale+Lonsdale:2019; @Bartram+Patra+Stone:2017; @Etchebehere+Fedorovskaya:2017]. 
In addition, the palettes do not perform well for viewers with some form
of colorblindness (nearly 10% of the population).
Most of the palettes also use sequences
of hues obtained in the RGB (red-green-blue) space or simple derivations thereof like HSV (hue-saturation-value) or HLS (hue-lightness-saturation),
which leads to clustering of colors at the red, green, and blue primaries.

In R version 2.1.0, Thomas Lumley added the `colorRampPalette()` function.
This makes it easier to generate a palette, though the user is still required
to select, for example, start and end colors from which
a palette of colors can then be interpolated.

Over time, 
better palettes became available via packages on CRAN (Comprehensive R Archive Network)
  starting with \CRANpkg{RColorBrewer} [@RColorBrewer], later
  \CRANpkg{colorspace} [@Ihaka:2003; @Zeileis+Hornik+Murrell:2009], and somewhat more recently
  \CRANpkg{viridis} [@viridis], \CRANpkg{rcartocolor} [@rcartocolor], or \CRANpkg{scico} [@scico],
  among many others.

In addition, higher-level graphics systems
 like \CRANpkg{ggplot2} [@ggplot2] and \CRANpkg{lattice} [@lattice]
developed their own color themes.

# A new set of R palettes

On the road to R version 4.0.0 an attempt was made to
address the limited and deficient set of palettes that are available 
within the core R graphics sytem and to add
a range of modern color palettes.

## A new default color palette

The default color palette in R -- the default set of colors that can
be specified by integer index -- has been replaced.  The new palette
follows the same basic hues as the old default palette, but
the palette is less saturated overall and
reduces the size of changes in chroma and luminance across the palette.
This produces a calmer and less distracting palette with a more
even visual impact.
An attempt has also been made to improve the discriminability
of the colors in the default palette for colorblind viewers.
The old, "R3", default palette
and the new, "R4" default palette are shown in
Figure \ref{fig:default}.

```{r swatch, echo=FALSE}
palette.swatch <- function(palette = palette.pals(), n = 8, nrow = 4,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, palette.colors, n = n)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}
```
```{r default, echo=FALSE, fig.height=2, fig.width=6, out.width='.6\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='The old, "R3", default palette and the new, "R4", default palette.'}
## height=5, width=12
palette.swatch(c("R3", "R4"), nrow=2)
```

We can also get the full set of colors from the default palette using the 
`palette()` function.

```{r}
palette()
```

More information about the construction of the new default palette
is given in [@grDevices2].

## The `palette.colors()` function

The `palette.colors()` function, new in R 4.0.0, provides a way to
access several other predefined palettes.  For example, by
default it returns the 
`Okabe-Ito` [@Okabe+Ito:2008] palette, which
 was designed to be very robust under color vision deficiencies.

```{r}
palette.colors()
```

The old R default palette is available via the name `R3`.

```{r}
palette.colors(palette = "R3")
```

Table \ref{tab:palettecolors} shows the full list
of palettes that are currently available, along with a description
of their source, and an image that displays the palette.
The `palette.pals()` function returns a character vector of 
the available palette names.

```{r}
palette.pals()
```

The first argument to `palette.colors()` is a number of colors.
For example, the following code just selects the first 4 colors from
the Okabe-Ito palette.

```{r}
palette.colors(4)
```

Each palette has a fixed number of colors;  we can ask for more, but
will only receive further colors if we ask for the palette to be
repeated.  The following code asks for 10 colors from the Okabe-Ito
palette, which only has 9, so the black is recycled.

```{r}
palette.colors(10, recycle = TRUE)
```

```{r echo=FALSE}
library(grid)
paletteGrid <- function(palette, n=NULL) {
    cols <- palette.colors(n, palette)
    n <- length(cols)
    ncol <- 10
    nrow <- ceiling(n / ncol)
    pushViewport(viewport(layout=grid.layout(nrow, ncol, respect=TRUE)),
                 viewport(layout.pos.col=1:ncol, layout.pos.row=1:nrow))
    x <- rep((1:ncol - 1)/ncol, nrow)[1:n]
    y <- rep(1 - (1:nrow - 1)/nrow, each=ncol)[1:n]
    grid.rect(x, y, just=c("left", "top"), 
              width=unit(1/ncol, "npc"),
              height=unit(1/nrow, "npc"),
              gp=gpar(fill=cols))
    popViewport(2)
}
```
```{r R3palette, echo=FALSE, fig.show="hide", fig.width=10, fig.height=1}
paletteGrid("R3")
```
```{r R4palette, echo=FALSE, fig.show="hide", fig.width=10, fig.height=1}
paletteGrid("R4")
```
```{r ggplot2palette, echo=FALSE, fig.show="hide", fig.width=10, fig.height=1}
paletteGrid("ggplot2")
```
```{r OkabeItopalette, echo=FALSE, fig.show="hide", fig.width=10, fig.height=1}
paletteGrid("Okabe-Ito")
```

\begin{table}
\begin{tabular}[ht]{l p{3in} p{1in}}
{\tt "R3"} & The default R palette prior to R 4.0.0 (8 colors) & 
  \includegraphics[scale=.1]{color_files/figure-latex/R3palette-1} \\[4mm]
{\tt "R4"} & The default R palette from R 4.0.0 (8 colors) &
  \includegraphics[scale=.1]{color_files/figure-latex/R4palette-1} \\[4mm]
{\tt "ggplot2"} & The \pkg{ggplot2} palette (8 colors) & 
  \includegraphics[scale=.1]{color_files/figure-latex/ggplot2palette-1} \\[4mm]
{\tt "Okabe-Ito"} & The `Okabe-Ito` \citep{Okabe+Ito:2008} palette, which
 was designed to be very robust under color vision deficiencies (9 colors). &
  \includegraphics[scale=.1]{color_files/figure-latex/OkabeItopalette-1} \\[4mm]
\end{tabular}
\caption{\label{tab:palettecolors}The color palettes provided by
`palette.colors()`.}
\end{table}


Each of these palettes can be set as the default palette by passing
the palette name to the `palette()` function.  For example,
the following code sets the Okabe-Ito palette as the default palette.

```{r}
palette("Okabe-Ito")
```

The palettes available via `palette.colors()` are known as 
*qualitative palettes* because they are appropriate for 
encoding qualitative (categorical) variables.  In other words,
these palettes are appropriate for differentiating between groups.

## The `hcl.colors()` function



\newpage

 base R was finally overcome by introducing two new palette functions:

- `palette.colors()` provides a new improved default color palette as well as a few other well-established qualitative palettes [@grDevices2]
- `hcl.colors()` provides a wide range of qualitative, sequential, and diverging palettes obtained by a standardized approach in
  the so-called HCL (hue-chroma-luminance) space [@Wiki+HCL], see @grDevices and @Zeileis+Fisher+Hornik:2020.
  Most of these HCL palettes approximate very closely well-established palettes from \pkg{RColorBrewer}, \pkg{viridis}, \pkg{rcartocolor},
  \pkg{scico}, and others.

Both are accompanied by functions to query the available palette names (`palette.pals()` and `hcl.pals()`, respectively).
The color swatches shown in Figures \ref{fig:palette}, \ref{fig:hcls}, and \ref{fig:hcld} which are also shown by running
the `example()` of the two functions which make basic `palette.swatch()` and `hcl.swatch()` functions available.
Here, focus on `palette.colors()`, more details on `hcl.colors()` later.

```{r palette, echo=FALSE, fig.height=3.5, fig.width=13, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{palette.colors()}.'}
## height=5, width=12
palette.swatch()
```

Briefly explain principles for selection of `R4` (similar hues, limited differences in chroma/luminance, dark/colorful, work ok for colorblind viewers).
`Okabe-Ito` [@Okabe+Ito:2008] was designed to be very robust under color vision deficiencies. As it uses somewhat different hues than the old `R4` palette
and was hence not used as the new default palette in R but it is the default in `palette.colors()`.
The robustness of both palettes is illustrated in Figure \ref{fig:cvd}.

```{r cvd, echo=FALSE, fig.height=3.5, fig.width=12, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Color vision deficiency emulation for \\code{R4} (left) and \\code{Okabe-Ito} (right) palettes.'}
layout(rbind(1:2), widths = c(0.46, 0.54))
swatchplot(palette.colors(palette = "R4"), cvd = TRUE)
swatchplot(palette.colors(palette = "Okabe-Ito"), cvd = TRUE)
```

The other palettes are from well-established software packages like \pkg{ggplot2} [@ggplot2], ColorBrewer.org [@Harrower+Brewer:2003],
or Tableau [@Tableau]. Moreover, two palettes with many colors (36 and 26, respectively) are used from the
\CRANpkg{Polychrome} package [@Polychrome].

## Illustration

Show usage of new qualitative palettes in practice. Consider:
Power of color often overestimated.
Color vision deficiencies ($\sim 8$% of male and $\sim 0.5$% of female viewers).
Other physical or technical limitations.

Starting point: Time series line plot using base graphics, see Figure \ref{fig:tsplot} (top left), essentially:

```{r tsplot-pseudocode, eval=FALSE}
p <- c(1:3, 5)
plot(EuStockMarkets, log = "y", plot.type = "single", col = p, ...)
legend("topleft", colnames(EuStockMarkets), col = p, ...)
```

The first two rows show the old default colors from R 3.x.y and the new default colors startin from R 4.0.0.
Additionally, the figure uses @Okabe+Ito:2008 palette and it switches from a color legend to direct labeling.

In the right column: Emulation of a kind of red-green
color blindness known as protanopia using the \pkg{colorspace} package based on
the algorithms of @Machado+Oliveira+Fernandes:2009.

```{r tsplot, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Time series line plot of \\code{EuStockMarkets}. Rows: Old \\code{"R3"} default palette (top), new \\code{"R4"} default palette (middle), \\code{"OkabeIto"} palette (bottom), designed to be robust under color vision deficiencies. Columns: Normal vision (left) and emulated protanope vision (right). A color legend is used in the first row and direct labels in the other rows.'}
tsplot <- function(palette = "R3", protan = FALSE, legend = TRUE, ...) {
  ## color palette
  palette <- match.arg(palette, c("R3", "R4", "Okabe-Ito"))
  p <- switch(palette,
    "R3" = palette.colors(8, "R3")[c(1:3, 5)],
    "R4" = palette.colors(8, "R4")[c(1:3, 5)],
    "Okabe-Ito" = palette.colors(4, "Okabe-Ito")[c(1, 4, 2, 3)]
  )
  
  ## emulate protanope vision?
  if(protan) p <- colorspace::protan(p) 
  
  ## time series plot
  eu <- window(EuStockMarkets, end = 1998)
  plot(eu, log = "y", ylab = "EU Stock Prices", plot.type = "single", col = p, xlim = c(1991.6, 1998.4), lwd = 1.5, ...)
  text(1991.3, 6000, palette, pos = 4, cex = 1.5)

  ## legend or direct labeling
  if(legend) {
    legend(1991.3, 6000, colnames(eu), col = p, lty = 1, lwd = 3, bty = "n")
  } else {
    text(1998, tail(eu, 1), colnames(eu), pos = 4, col = p, xpd = TRUE)
  }
  
  invisible(p)
}

par(mfrow = c(3, 2), mar = c(5, 4, 2, 1))
tsplot(palette = "R3", protan = FALSE, legend = TRUE, main = "Normal")
tsplot(palette = "R3", protan = TRUE, legend = TRUE, main = "Protanope")
par(mar = c(5, 4, 1, 1))
tsplot(palette = "R4", protan = FALSE, legend = FALSE)
tsplot(palette = "R4", protan = TRUE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = FALSE, legend = FALSE)
tsplot(palette = "Okabe-Ito", protan = TRUE, legend = FALSE)
```

Old `R3` default palette: Too flashy, cyan too light, hard to distinguish for protanope viewers.
The colors for the German stock index DAX and the Swiss stock index SMI look almost identical to protanope viewers.

New `R4` default palette: Similar hues, more balanced brightness, avoid garish colors, distinguishable for viewers with color vision deficiencies. Cyan much better.

`Okabe-Ito`: Even easier to distinguish.


# HCL-based color palettes

## Construction principles

HCL makes it easy to describe colors for humans, using the three basic properties hue, chroma, and luminance (see Figure \ref{fig:hcl}).

```{r hcl, echo=FALSE, fig.height=2.4, fig.width=5, out.width='0.4\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Varying hue, chroma, and luminance separately, keeping the other two properties fixed.'}
swatchplot(
  "Hue\n(Type of color)"    = sequential_hcl(5, h = c(0, 300), c = c(60, 60), l = 65),
  "Chroma\n(Colorfulness)"  = sequential_hcl(5, h = 0, c = c(100, 0), l = 65, rev = TRUE, power = 1),
  "Luminance\n(Brightness)" = sequential_hcl(5, h = 260, c = c(25, 25), l = c(25, 90), rev = TRUE, power = 1),
  nrow = 3, line = 8, off = 0
)
```

For qualitative palettes mainly vary hue. Completely balanced if chroma and luminance kept fixed which
was suggested by @Ihaka:2003 and is implemented in `hcl.colors()`. See left panel of Figure \ref{fig:hclpal}
and Figure \ref{fig:hclq}.
Two drawbacks: Relatively few colors that can be clearly distinguished (about six), even fewer under
color vision deficiencies (about three). Hence in most situations better allow limited variations in chroma and luminance
as in `palette.colors()`. No general HCL-based strategy for such palettes.

```{r hclpal, echo=FALSE, fig.height=2.4, fig.width=15, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Basic idea for HCL palettes.'}
swatchplot(
  "Qualitative (Set 2)"     = rbind("Color" = hcl.colors(5, "Set 2"),     "Desaturated" = desaturate(hcl.colors(5, "Set 2"))),
  "Sequential (Blues)"    = rbind("Color" = hcl.colors(7, "Blues"),    "Desaturated" = desaturate(hcl.colors(7, "Blues"))),
  "Diverging (Green-Brown)" = rbind("Color" = hcl.colors(7, "Green-Brown"), "Desaturated" = desaturate(hcl.colors(7, "Green-Brown"))),
  nrow = 3, off = 0, line = 7
)
```
For sequential and diverging palettes monotonic changes in luminance are most important (see middle and right panel
in Figure \ref{fig:hclpal}). Add changes in chroma and possibly also hue (see Figure \ref{fig:specplot}).
`Blues 2` uses a constant hue and monotonic changes in chroma and luminance going from dark and colorful blue to
light gray. `Blues` uses similar luminance trajectory, slightly varies hue, and has triangular chroma curve (rather
than monotonic). `Blues 2` mostly emphasizes the dark and colorful blue while `Blues` makes the colors more easily
distinguishable in the middle.

Diverging combines two sequential, making both arms as balanced as possible.


```{r specplot, echo=TRUE, fig.height=5, fig.width=5, fig.show='hide'}
specplot(hcl.colors(7, "Blues"), hcl.colors(7, "Blues 2"))
specplot(hcl.colors(7, "Green-Brown"))
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-1} 
\includegraphics[width=0.49\textwidth]{color_files/figure-latex/specplot-2}
\caption{Spectrum of luminance (blue, left axis), chroma (green, left axis), and hue (red, right axis) trajectories.
Left: Sequential \code{Blues} (solid) and \code{Blues 2} (dashed) palettes.
Right: Diverging \code{Green-Brown} palette.}\label{fig:specplot}
\end{figure}


## Available palettes

Overview of qualitative (Figure \ref{fig:hclq}), sequential (Figure \ref{fig:hcls}), and diverging (Figure \ref{fig:hcld})
palettes based on HCL principles. Many closely approximate colors from ColorBrewer.org, CARTO Color, Viridis, and 
Crameri's scientific colors. See <http://colorspace.R-Forge.R-project.org/articles/approximations.html> for one-to-one
comparisons.

```{r hclq, echo=FALSE, fig.height=2, fig.width=8, out.width='0.85\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Qualitative palettes from \\code{hcl.colors()}.'}
hcl.swatch <- function(palette = NULL, type = NULL, n = 5, nrow = 11,
  border = if (n < 15) "black" else NA, ...) {
    if(is.null(palette)) palette <- hcl.pals(type)
    cols <- sapply(palette, hcl.colors, n = n)
    ncol <- ncol(cols)
    nswatch <- min(ncol, nrow)

    par(mar = rep(0.1, 4),
        mfrow = c(1, min(6, ceiling(ncol/nrow))),
        cex = 0.7, ...)

    while (length(palette)) {
        subset <- 1:min(nrow, ncol(cols))
        plot.new()
        plot.window(c(0, n), c(0, nrow + 1))
        text(0, rev(subset) + 0.1, palette[subset], adj = c(0, 0))
        y <- rep(subset, each = n)
        rect(rep(0:(n-1), n), rev(y), rep(1:n, n), rev(y) - 0.5,
             col = cols[, subset], border = border)
        palette <- palette[-subset]
        cols <- cols[, -subset, drop = FALSE]
    }

    par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), cex = 1)
}

hcl.swatch(type = "qualitative", nrow = 2)
```

```{r hcls, echo=FALSE, fig.height=9, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Sequential palettes from \\code{hcl.colors()}.'}
hcl.swatch(type = "sequential", nrow = 12)
```

```{r hcld, echo=FALSE, fig.height=4.5, fig.width=10, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='Diverging palettes from \\code{hcl.colors()}.'}
hcl.swatch(c(hcl.pals("diverging"), hcl.pals("divergingx")), nrow = 6)
```

## Illustration

Risk maps: Communication to the public particularly important.

Example: Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04, during hurricane Dorian.

Source: National Oceanic and Atmospheric Administration.

Original: Works poorly because too much chroma everywhere and non-monotonic luminance (dark to light and back to dark).
Extremely hard to read for colorblind viewers (see Figure \ref{fig:dorian}).

Better HCL-based alternative: `OrRd` and also merging some probability intervals to make matching of intervals to colors easier, still clearly conveys overall shape.

Might have contributed to Trump's confusion in "Sharpiegate" incident. See @Zeileis+Stauffer:2019 for a more detailed discussion and other alternative color palettes.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orig-deutan.png} 

\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd.png} 
\includegraphics[width=0.49\textwidth]{images/dorian-useR-2021-orrd-deutan.png} 
\caption{Probability of wind speeds $>$ 39\,mph (63\,km\,h$^{-1}$), 2019-08-30--2019-09-04..}\label{fig:dorian}
\end{figure}




# New defaults in graphical functions

Many graphics functions have now slightly different default output, namely when they are using colors `2`, `3`, `4`, etc. but still red, green, blue.

Moreover, a couple of functions explicitly have new defauls, namely: `image()` and `filled.contour()`, now using sequential `YlOrRd` palette
(from ColorBrewer) which uses similar hues as the old `heat.colors()`. See Figure \ref{fig:graphics}.

Finally, it might be worth mentioning that `hist()` and `boxplot()` (and thus `plot(num ~ factor, ...)`) have a new default color:
light gray which makes it a bit easier to compare the shaded areas.

```{r graphics, echo=-1, fig.height=4, fig.width=14, out.width='\\textwidth', fig.align='center', fig.pos='htbp', fig.cap='New defaults in base graphics.'}
par(mfrow = c(1, 3))
image(volcano)
boxplot(weight ~ feed, data = chickwts)
hist(chickwts$weight)
```


